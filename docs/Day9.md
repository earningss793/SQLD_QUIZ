**DAY 9: 집합 연산자와 그룹 함수**

## 🟢 1단계: 기초 - "모양 맞추기와 합치기"

**[Q1] 집합 연산자를 사용하여 두 개의 SELECT 문을 결합할 때, 반드시 지켜야 할 규칙으로 옳지 않은 것은?**

* ① 두 쿼리의 컬럼 개수가 동일해야 한다.
* ② 각 컬럼의 데이터 타입이 상호 호환 가능해야 한다.
* ③ 두 쿼리의 컬럼 명칭이 반드시 동일해야 한다.
* ④ SELECT 절의 컬럼 순서가 일치해야 한다.

> **정답:** ③
> **해설:** 컬럼 명칭이 달라도 데이터 타입과 개수만 맞으면 결합이 가능합니다. 결과의 컬럼명은 첫 번째 SELECT 문을 따릅니다.
> **힌트:** '틀(구조)'은 맞춰야 하지만, '이름표'는 첫 번째 사람 것을 빌려 쓴다고 생각하세요.

**[Q2] 다음 중 두 집합의 중복된 행을 제거하고 합집합 결과를 반환하는 연산자는?**

* ① UNION
* ② UNION ALL
* ③ INTERSECT
* ④ MINUS

> **정답:** ①
> **해설:** `UNION`은 합집합을 구하면서 중복을 제거하고 정렬을 수행합니다. `UNION ALL`은 중복을 포함합니다.
> **힌트:** `UNION`은 '유니크(Unique)'하게 합친다고 기억하세요.

**[Q3] 다음 중 두 테이블에서 공통으로 존재하는 행만 추출하고 싶을 때 사용하는 집합 연산자는?**

* ① UNION
* ② MINUS
* ③ INTERSECT
* ④ EXCEPT

> **정답:** ③
> **해설:** `INTERSECT`는 교집합을 의미하며 양쪽에 모두 존재하는 데이터만 결과로 냅니다.
> **힌트:** 벤다이어그램의 겹치는 부분을 떠올려 보세요.

**[Q4] SQL Server 환경에서 차집합을 구하기 위해 사용하는 연산자는?**

* ① MINUS
* ② EXCEPT
* ③ DIFFERENCE
* ④ SUBTRACT

> **정답:** ②
> **해설:** Oracle은 `MINUS`를 사용하지만, SQL Server(T-SQL)는 `EXCEPT`를 사용합니다.
> **힌트:** "Oracle은 마이너스(-), MS는 익셉트(Except)!"

**[Q5] `GROUP BY ROLLUP(DEPTNO)` 쿼리를 실행했을 때 나오는 결과의 구성으로 옳은 것은?**

* ① 부서별 합계만 출력된다.
* ② 전체 총계만 출력된다.
* ③ 부서별 합계와 전체 총계가 함께 출력된다.
* ④ 부서별 합계와 직업별 합계가 함께 출력된다.

> **정답:** ③
> **해설:** `ROLLUP`은 나열된 컬럼에 대해 계층적인 소계와 전체 총계를 생성합니다.
> **힌트:** "롤(ROLL)업은 아래에서 위로 말아 올리듯 총계까지 낸다!"

---

## 🟡 2단계: 중급 - "정렬과 성능의 차이"

**[Q6] 집합 연산자를 사용한 SQL 문에서 `ORDER BY` 절의 위치로 가장 적절한 것은?**

* ① 첫 번째 SELECT 문 바로 뒤
* ② 각 SELECT 문 마다 각각 사용
* ③ 마지막 SELECT 문의 맨 마지막에 딱 한 번 사용
* ④ 집합 연산자 바로 앞에 사용

> **정답:** ③
> **해설:** `ORDER BY`는 집합 연산으로 합쳐진 전체 결과에 대해 적용되므로 맨 마지막에 위치해야 합니다.
> **힌트:** 모든 데이터가 다 모인 다음에 정렬(줄 세우기)을 해야 의미가 있겠죠?

**[Q7] `UNION`과 `UNION ALL`의 성능 차이에 대한 설명으로 가장 적절한 것은?**

* ① `UNION`은 중복 제거를 위해 내부적으로 정렬을 수행하므로 `UNION ALL`보다 느리다.
* ② `UNION ALL`은 중복을 확인해야 하므로 `UNION`보다 느리다.
* ③ 두 연산자의 성능 차이는 없다.
* ④ `UNION ALL`은 인덱스를 사용할 수 없어 `UNION`보다 느리다.

> **정답:** ①
> **해설:** `UNION`은 중복 제거(Distinct)를 위해 데이터 정렬(Sort) 과정을 거치므로 시스템 부하가 더 큽니다.
> **힌트:** "중복 검사 안 하고 그냥 붙이는 `UNION ALL`이 광속이다!"

**[Q8] `GROUP BY ROLLUP(A, B)`의 집계 조합으로 옳은 것은?**

* ① (A, B), (A), ()
* ② (A, B), (B), ()
* ③ (A, B), (A), (B)
* ④ (A), (B), ()

> **정답:** ①
> **해설:** `ROLLUP`은 오른쪽 인수를 하나씩 제거하며 집계합니다. (A, B) -> (A) -> () 순서입니다.
> **힌트:** 오른쪽 끝에서부터 하나씩 지우개로 지워나간다고 생각하세요.

**[Q9] 다음 중 모든 가능한 조합에 대해 다차원적인 집계를 생성하는 함수는?**

* ① ROLLUP
* ② CUBE
* ③ GROUPING SETS
* ④ RANK

> **정답:** ②
> **해설:** `CUBE`는 결합 가능한 모든 조합(2^N)에 대해 소계와 총계를 구합니다.
> **힌트:** 정육면체(Cube)처럼 모든 면을 다 집계한다고 이해하세요.

**[Q10] 집합 연산자 사용 시 데이터 타입에 대한 설명 중 옳은 것은?**

* ① 문자와 숫자를 결합하면 자동으로 문자로 변환되어 결합된다.
* ② 데이터 타입이 달라도 컬럼 순서만 맞으면 오류가 발생하지 않는다.
* ③ 데이터 타입은 반드시 일치하거나 상호 호환 가능한 유형이어야 한다.
* ④ 날짜형과 숫자형은 집합 연산이 불가능하다.

> **정답:** ③
> **해설:** 집합 연산자는 암시적 형변환을 일부 지원하지만, 원칙적으로 데이터 타입이 호환되어야 하며 다를 경우 오류가 발생할 확률이 높습니다.
> **힌트:** "사과는 사과끼리, 배는 배끼리 쌓아야 안 무너집니다."

---

## 🟠 3단계: 상급 - "그룹 함수의 디테일"

**[Q11] `GROUP BY CUBE(A, B, C)`를 수행했을 때 생성되는 집계 조합의 총 개수는? (전체 총계 포함)**

* ① 3개
* ② 4개
* ③ 7개
* ④ 8개

> **정답:** ④
> **해설:** `CUBE`의 집계 조합은 개입니다. 인수가 3개이므로 개입니다.
> **힌트:** 조합(Combination)의 모든 경우의 수입니다.

**[Q12] `INTERSECT` 연산자에 대한 설명으로 적절하지 않은 것은?**

* ① 두 집합의 공통된 행을 반환한다.
* ② 중복된 행은 하나로 표시된다.
* ③ 내부적으로 정렬 작업을 수행한다.
* ④ 첫 번째 집합에만 존재하는 행을 반환한다.

> **정답:** ④
> **해설:** ④번 설명은 `MINUS`(또는 `EXCEPT`)에 대한 설명입니다.
> **힌트:** `INTERSECT`는 '교집합'입니다.

**[Q13] `GROUP BY ROLLUP(A, B)`와 `GROUP BY ROLLUP(B, A)`의 결과에 대한 설명으로 옳은 것은?**

* ① 두 결과는 항상 동일하다.
* ② 계층 구조가 다르므로 소계의 구성과 행의 수가 달라질 수 있다.
* ③ 전체 총계 행의 값이 서로 다르게 계산된다.
* ④ 두 함수 모두 모든 조합의 소계를 출력한다.

> **정답:** ②
> **해설:** `ROLLUP`은 인수의 순서에 따라 계층(Hierarchy)이 결정되므로 순서가 중요합니다.
> **힌트:** "부서별 직업합계"와 "직업별 부서합계"는 소계의 의미가 다릅니다.

**[Q14] 다음 중 원하는 집계 대상 컬럼을 자유롭게 나열하여 특정 소계만 구하고 싶을 때 가장 효율적인 함수는?**

* ① ROLLUP
* ② CUBE
* ③ GROUPING SETS
* ④ CASE WHEN

> **정답:** ③
> **해설:** `GROUPING SETS`는 지정한 조합만 집계하므로 불필요한 연산을 줄이고 유연하게 사용 가능합니다.
> **힌트:** "원하는 것만 쏙쏙 골라 담는 그룹핑 세츠!"

**[Q15] `GROUPING` 함수가 반환하는 값의 의미로 옳은 것은?**

* ① 해당 행이 실제 데이터 행이면 1, 집계 행이면 0을 반환한다.
* ② 해당 행이 소계/총계를 위해 생성된 행이면 1, 아니면 0을 반환한다.
* ③ 해당 컬럼의 NULL 값을 0으로 변환한다.
* ④ 그룹화된 행의 개수를 반환한다.

> **정답:** ②
> **해설:** `GROUPING` 함수는 집계용으로 생성된 NULL을 판별하기 위해 사용하며, 집계 행일 때 1을 반환합니다.
> **힌트:** "집계 행이 맞나요? (1: Yes / 0: No)"

---

## 🔴 4단계: 심화 - "고득점 킬러 문항"

**[Q16] 다음 중 `GROUP BY ROLLUP(A, B)`와 동일한 결과를 반환하는 것은?**

* ① `GROUP BY GROUPING SETS((A, B), (A), ())`
* ② `GROUP BY GROUPING SETS((A, B), (B), ())`
* ③ `GROUP BY CUBE(A, B)`
* ④ `GROUP BY A, B UNION ALL GROUP BY A`

> **정답:** ①
> **해설:** `ROLLUP`의 계층 구조를 `GROUPING SETS`로 풀어서 표현하면 (A,B), (A), ()와 같습니다. ()는 전체 총계를 의미합니다.
> **힌트:** 시험에 정말 자주 나옵니다! `ROLLUP`을 수동으로 구현하는 법을 익히세요.

**[Q17] 집합 연산자 사용 시 NULL 값의 처리에 대한 설명으로 옳은 것은?**

* ① 집합 연산자는 NULL을 값으로 인식하지 못해 무시한다.
* ① 두 행의 컬럼 값이 모두 NULL이면 서로 다른 값으로 간주하여 중복 제거가 안 된다.
* ③ 집합 연산자는 NULL을 서로 동일한 값으로 인식하여 중복을 제거한다.
* ④ `UNION ALL`에서만 NULL이 표시된다.

> **정답:** ③
> **해설:** `WHERE` 절 비교와 달리, 집합 연산자(UNION, INTERSECT 등)는 NULL을 같은 값으로 취급하여 중복을 제거합니다.
> **힌트:** "집합 연산자 세계에서는 NULL끼리 친구(동일함)입니다."

**[Q18] 다음 SQL의 결과로 가장 적절한 것은?**

```sql
SELECT JOB, SUM(SAL) FROM EMP
GROUP BY GROUPING SETS((JOB), ());

```

* ① 직업별 합계만 출력된다.
* ② 전체 총계만 출력된다.
* ③ 직업별 합계와 전체 총계가 출력된다.
* ④ 오류가 발생한다.

> **정답:** ③
> **해설:** `(JOB)`은 직업별 합계를, `()`는 빈 괄호로 전체 총계를 의미합니다.
> **힌트:** `GROUPING SETS` 안의 빈 괄호는 `GRAND TOTAL`의 마법 주문입니다.

**[Q19] 성능 최적화 관점에서 `UNION ALL`이 가능한 상황임에도 `UNION`을 사용하는 것이 부적절한 이유는?**

* ① `UNION`은 결과가 항상 더 적게 나오기 때문이다.
* ② 불필요한 정렬(Sort) 부하가 발생하여 응답 속도가 느려지기 때문이다.
* ③ `UNION`은 인덱스 스캔을 강제하기 때문이다.
* ④ `UNION`은 서브쿼리 내에서 사용이 불가능하기 때문이다.

> **정답:** ②
> **해설:** 데이터의 중복이 없다는 것을 이미 알고 있다면, 정렬 부하가 있는 `UNION`보다는 `UNION ALL`이 훨씬 효율적입니다.
> **힌트:** "DB에게 힘든 정렬 시키지 마세요!"

**[Q20] 아래 SQL의 빈칸에 들어갈 코드로 '부서 합계'라는 명칭을 부여하고 싶을 때 가장 적절한 것은?**

```sql
SELECT 
    CASE WHEN (  빈칸  ) = 1 THEN '부서 합계' ELSE JOB END AS 명칭,
    SUM(SAL)
FROM EMP
GROUP BY ROLLUP(JOB);

```

* ① `COUNT(JOB)`
* ② `GROUPING(JOB)`
* ③ `NVL(JOB)`
* ④ `ISNULL(JOB)`

> **정답:** ②
> **해설:** `ROLLUP`으로 인해 생성된 소계 행은 `GROUPING(컬럼)`의 결과가 1이 됩니다. 이를 `CASE`나 `DECODE`로 처리해 이름을 바꿉니다.
> **힌트:** `GROUPING`은 보고서의 예쁜 이름을 만들어주는 일등공신입니다.

---
