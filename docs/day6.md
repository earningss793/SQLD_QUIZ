제공해주신 1강부터 5강까지의 강의 내용을 바탕으로, SQLD 시험의 출제 포인트와 실무 활용도를 반영한 **텍스트 기반 퀴즈 20문항**을 작성했습니다.

---

### [1~2강: SELECT와 WHERE 절]

**[문항 1] 다음 중 SQL 문법의 특징으로 가장 적절하지 않은 것은?**

1. SQL 문장은 세미콜론(;)으로 끝내야 실행된다.
2. SQL 명령어(SELECT, FROM 등)는 대소문자를 구별하지 않는다.
3. 데이터 값('Kim', 'MANAGER')은 대소문자를 엄격히 구별한다.
4. 산술 연산에서 NULL과 숫자를 더하면 0이 된다.

* **정답:** 4)
* **해설:** NULL은 '알 수 없는 값'이므로, 어떤 숫자와 연산해도 결과는 무조건 NULL입니다. (100 + NULL = NULL)
* **힌트:** NULL은 0이 아닙니다.

**[문항 2] 별칭(Alias) 사용 규칙 중 옳은 것은?**

1. AS 키워드는 반드시 사용해야 한다.
2. 별칭에 공백이 포함된 경우 작은따옴표(' ')로 감싸야 한다.
3. 별칭에 공백이나 특수문자가 있으면 큰따옴표(" ")를 사용해야 한다.
4. WHERE 절에서 SELECT 절의 별칭을 사용하여 필터링할 수 있다.

* **정답:** 3)
* **해설:** 별칭에 공백이 있을 때는 반드시 큰따옴표(")를 써야 합니다. WHERE 절은 SELECT 절보다 먼저 실행되므로 SELECT에서 만든 별칭을 인식하지 못합니다.
* **힌트:** 이름표(Alias)는 크게(") 붙인다고 생각하세요.

**[문항 3] 다음 중 이름이 'K'로 시작하고 세 번째 글자가 'M'인 데이터를 찾는 조건으로 옳은 것은?**

1. WHERE NAME LIKE 'K%M'
2. WHERE NAME LIKE 'K_M%'
3. WHERE NAME LIKE 'K%M%'
4. WHERE NAME LIKE 'K_M_'

* **정답:** 2)
* **해설:** 'K'로 시작(K), 두 번째 글자 상관없음(_), 세 번째 글자(M), 그 뒤는 상관없음(%)의 조합입니다.
* **힌트:** '_'는 딱 한 글자, '%'는 글자 수 제한이 없습니다.

**[문항 4] 다음 중 보너스(COMM)가 NULL인 사원을 조회하는 올바른 쿼리는?**

1. SELECT * FROM EMP WHERE COMM = NULL;
2. SELECT * FROM EMP WHERE COMM != NULL;
3. SELECT * FROM EMP WHERE COMM IS NULL;
4. SELECT * FROM EMP WHERE COMM IS NOT NULL;

* **정답:** 3)
* **해설:** NULL은 값이 아니므로 '=' 연산자를 쓸 수 없고, 반드시 IS NULL 연산자를 사용해야 합니다.
* **힌트:** 비어있는 상태를 묻는 전용 연산자가 있습니다.

**[문항 5] 연산자 우선순위에 따라 다음 조건의 결과로 옳은 것은?**
`WHERE DEPTNO = 10 OR DEPTNO = 20 AND SAL > 2500`

1. 10번 부서이거나 20번 부서인 사람 중 급여가 2500 초과인 사원
2. 10번 부서인 사람 전체와, 20번 부서이면서 급여가 2500 초과인 사원
3. 부서와 상관없이 급여가 2500 초과인 사원
4. 10번과 20번 부서 사원 중 급여가 2500 이하인 사원

* **정답:** 2)
* **해설:** 논리 연산자 순위는 NOT > AND > OR입니다. 따라서 AND 조건이 먼저 계산됩니다.
* **힌트:** AND가 OR보다 힘이 더 셉니다.

---

### [3강: ORDER BY와 함수]

**[문항 6] 다음 중 SQL 실행 순서로 올바른 것은?**

1. SELECT → FROM → WHERE → ORDER BY
2. FROM → SELECT → WHERE → ORDER BY
3. FROM → WHERE → SELECT → ORDER BY
4. WHERE → FROM → SELECT → ORDER BY

* **정답:** 3)
* **해설:** 재료 창고(FROM)에서 재료를 손질(WHERE)한 뒤, 플레이팅(SELECT)하고, 마지막에 줄을 세웁니다(ORDER BY).
* **힌트:** '프-웨-셀-오'를 기억하세요. (중간에 그룹핑이 빠진 기초 순서)

**[문항 7] Oracle 환경에서 `ORDER BY SAL ASC`를 실행했을 때, SAL이 NULL인 데이터는 어디에 위치하는가?**

1. 가장 처음에 출력된다.
2. 가장 마지막에 출력된다.
3. 무작위로 출력된다.
4. 출력에서 제외된다.

* **정답:** 2)
* **해설:** Oracle은 NULL을 가장 큰 값으로 취급하므로 오름차순(ASC) 시 맨 뒤에 옵니다. (SQL Server는 반대)
* **힌트:** Oracle에서 NULL은 끝판왕(가장 큰 값)입니다.

**[문항 8] `SELECT SUBSTR('SQLD_PASS', 6, 2) FROM DUAL;`의 결과값은?**

1. 'PA'
2. 'AS'
3. 'SS'
4. 'D_'

* **정답:** 1)
* **해설:** 6번째 글자인 'P'부터 시작하여 2글자를 가져오므로 'PA'가 됩니다.
* **힌트:** 시작 위치와 가져올 개수를 확인하세요.

**[문항 9] 다음 중 NULL 처리 함수에 대한 설명으로 틀린 것은?**

1. NVL(A, B): A가 NULL이면 B를 반환한다.
2. NULLIF(A, B): A와 B가 같으면 NULL을 반환한다.
3. COALESCE(A, B, C): 리스트 중 NULL이 아닌 최초의 값을 반환한다.
4. NVL2(A, B, C): A가 NULL이면 B를, 아니면 C를 반환한다.

* **정답:** 4)
* **해설:** NVL2(A, B, C)는 A가 NULL이 **아니면** B를, NULL**이면** C를 반환합니다.
* **힌트:** NVL2는 'NULL이 아닐 때'가 먼저 옵니다.

**[문항 10] CASE 문의 두 가지 방식 중 'Searched Case Expression'의 특징은?**

1. CASE 뒤에 바로 컬럼명을 쓴다.
2. WHEN 뒤에 비교 연산자나 복합 조건을 자유롭게 쓸 수 있다.
3. 등호(=) 비교만 가능하다.
4. Oracle의 DECODE 함수와 완전히 동일한 문법이다.

* **정답:** 2)
* **해설:** Searched Case는 `CASE WHEN 조건 THEN ...` 형태이며 다양한 조건을 걸 수 있습니다.
* **힌트:** `CASE WHEN SAL >= 3000`과 같은 형태입니다.

---

### [4강: GROUP BY와 HAVING]

**[문항 11] 다음 중 집계 함수와 NULL의 관계에 대한 설명으로 틀린 것은?**

1. COUNT(*)은 NULL을 포함하여 전체 행 수를 샌다.
2. COUNT(컬럼명)은 NULL을 제외한 행 수를 샌다.
3. SUM(컬럼명)은 NULL을 0으로 치환하여 합산한다.
4. AVG(컬럼명)은 NULL인 행을 분모에서 제외하고 평균을 구한다.

* **정답:** 3)
* **해설:** 집계 함수(SUM, AVG 등)는 NULL 값을 무시(제외)하고 연산합니다. 0으로 치환하는 것이 아닙니다.
* **힌트:** 대부분의 집계 함수는 NULL을 투명인간 취급합니다.

**[문항 12] 다음 쿼리에서 에러가 발생하는 이유는?**
`SELECT DEPTNO, ENAME, AVG(SAL) FROM EMP GROUP BY DEPTNO;`

1. 집계 함수를 SELECT 절에 썼기 때문에
2. GROUP BY 절에 ENAME 컬럼이 없기 때문에
3. WHERE 절이 없기 때문에
4. AVG 함수에 별칭을 주지 않았기 때문에

* **정답:** 2)
* **해설:** GROUP BY를 사용할 경우, SELECT 절에는 GROUP BY에 명시된 컬럼이나 집계 함수만 올 수 있습니다.
* **힌트:** 그룹으로 묶었는데, 묶이지 않은 개별 데이터(이름)를 부르라고 하면 컴퓨터는 혼란에 빠집니다.

**[문항 13] WHERE 절과 HAVING 절의 차이점으로 옳은 것은?**

1. WHERE 절에서도 집계 함수를 사용할 수 있다.
2. HAVING 절은 반드시 GROUP BY 절보다 먼저 실행된다.
3. WHERE 절은 개별 행을, HAVING 절은 그룹화된 결과를 필터링한다.
4. HAVING 절에는 일반 컬럼 조건만 올 수 있다.

* **정답:** 3)
* **해설:** WHERE는 그룹화 전 필터링, HAVING은 그룹화 후 집계 결과 필터링입니다.
* **힌트:** "박스에 담기 전(WHERE) vs 담은 후 무게 측정(HAVING)" 비유를 떠올리세요.

**[문항 14] SQL 전체 실행 순서(Logical Execution Order)를 올바르게 나열한 것은?**

1. FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY
2. SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY
3. FROM - GROUP BY - WHERE - HAVING - SELECT - ORDER BY
4. FROM - WHERE - SELECT - GROUP BY - HAVING - ORDER BY

* **정답:** 1)
* **해설:** 프-웨-그-하-셀-오(FWGHSO) 순서입니다.
* **힌트:** 이 순서는 SQLD 시험의 핵심 암기 사항입니다.

---

### [5강: JOIN]

**[문항 15] 다음 중 INNER JOIN에 대한 설명으로 옳은 것은?**

1. 한쪽 테이블에만 데이터가 있어도 모두 출력한다.
2. 조인 조건에 맞는 교집합 데이터만 출력한다.
3. 조건 없이 두 테이블의 모든 행을 곱하여 출력한다.
4. ANSI 표준에서는 WHERE 절에 조인 조건을 쓴다.

* **정답:** 2)
* **해설:** INNER JOIN은 양쪽 테이블에 모두 데이터가 존재하는 '커플' 데이터만 가져옵니다.
* **힌트:** 벤다이어그램의 교집합 영역입니다.

**[문항 16] LEFT OUTER JOIN의 결과에 대한 설명으로 옳은 것은?**

1. 오른쪽 테이블의 모든 데이터가 출력된다.
2. 조인 조건에 맞는 데이터가 없으면 왼쪽 테이블 데이터도 출력되지 않는다.
3. 왼쪽 테이블의 모든 데이터가 출력되며, 오른쪽 테이블에 짝이 없으면 NULL로 표시된다.
4. 양쪽 테이블의 모든 데이터가 합쳐져서 출력된다.

* **정답:** 3)
* **해설:** LEFT 테이블은 무조건 다 나오고, 매칭되는 오른쪽 데이터가 없으면 NULL 처리됩니다.
* **힌트:** 마케팅 타겟팅(전체 회원 중 구매 안 한 사람 찾기)에 자주 씁니다.

**[문항 17] Oracle 전용 조인 문법에서 `WHERE D.DEPTNO = E.DEPTNO(+)`의 의미는?**

1. EMP(E) 테이블 기준 LEFT OUTER JOIN
2. DEPT(D) 테이블 기준 LEFT OUTER JOIN
3. FULL OUTER JOIN
4. INNER JOIN

* **정답:** 2)
* **해설:** (+) 기호는 데이터가 부족한 쪽에 붙입니다. DEPT는 그대로 다 나오고 EMP가 부족하므로 DEPT 기준 조인입니다.
* **힌트:** (+)가 붙은 반대쪽 테이블이 주인(기준)입니다.

**[문항 18] NATURAL JOIN 사용 시 주의사항으로 옳은 것은?**

1. ON 절을 사용하여 조인 조건을 명시해야 한다.
2. 조인 컬럼에 테이블 별칭(Alias)을 붙일 수 없다.
3. 동일한 이름의 컬럼이 없어도 자동으로 조인된다.
4. WHERE 절에서 조인 컬럼을 쓸 때 반드시 테이블 별칭을 써야 한다.

* **정답:** 2)
* **해설:** NATURAL JOIN은 컬럼명을 자동으로 매칭하므로, 해당 컬럼에 별칭(E.DEPTNO 등)을 붙이면 에러가 납니다.
* **힌트:** 자동으로 합쳐졌으니 주인(별칭)을 따지지 말라는 뜻입니다.

**[문항 19] 사원 테이블(14행)과 부서 테이블(4행)을 CROSS JOIN 했을 때 결과 행의 개수는?**

1. 14개
2. 4개
3. 18개
4. 56개

* **정답:** 4)
* **해설:** CROSS JOIN(카티션 곱)은 모든 조합을 구하므로 이 됩니다.
* **힌트:** 두 테이블의 행 수를 곱하면 됩니다.

**[문항 20] 다음 중 비등가 조인(Non-EQUI JOIN)이 필요한 상황은?**

1. 사원번호와 부서번호가 일치하는 데이터를 찾을 때
2. 사원의 급여가 급여 등급 테이블의 최소~최대 범위에 있는지 확인할 때
3. 두 테이블의 컬럼 이름이 완전히 같을 때
4. 한쪽 테이블에만 데이터가 있는 경우를 찾을 때

* **정답:** 2)
* **해설:** 등호(=)가 아닌 BETWEEN, >, < 등의 연산자로 범위를 조인하는 것이 비등가 조인입니다.
* **힌트:** 딱 맞아떨어지는 값 대신 범위를 비교할 때 씁니다.

