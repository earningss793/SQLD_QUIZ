

# 🏆 SQLD 전체 범위 실전 대비 50문항 종합 퀴즈

## [제1과목] 데이터 모델링의 이해 (Q1 ~ Q15)

**Q1. 데이터 모델링의 3대 특징으로 올바르지 않은 것은?**
① 추상화 (Abstraction)
② 복제성 (Duplication)
③ 단순화 (Simplification)
④ 명확화 (Clarity)

* **정답:** ②
* **힌트:** 현실을 그대로 복제하는 것이 아니라 불필요한 것을 버리는 과정입니다.
* **해설:** 데이터 모델링은 현실 세계를 일정한 형식에 맞추어 표현하는 추상화, 단순화, 명확화(추·단·명)의 특징을 가집니다. (Day 15)

**Q2. 데이터베이스 설계 시 진행되는 데이터 모델링의 순서로 알맞은 것은?**
① 논리적 모델링 ➔ 개념적 모델링 ➔ 물리적 모델링
② 개념적 모델링 ➔ 물리적 모델링 ➔ 논리적 모델링
③ 개념적 모델링 ➔ 논리적 모델링 ➔ 물리적 모델링
④ 물리적 모델링 ➔ 논리적 모델링 ➔ 개념적 모델링

* **정답:** ③
* **힌트:** 추상화 수준이 가장 높은 단계부터 구체적인 물리적 구현 단계 순으로 진행됩니다.
* **해설:** 데이터 모델링은 큰 틀의 업무를 분석하는 개념적 모델링부터 시작해, 식별자와 관계를 정의하고 정규화를 수행하는 논리적 모델링, 데이터베이스 성능과 저장 구조를 설계하는 물리적 모델링 순으로 진행됩니다.

**Q3. 다음 중 '물리적 데이터 독립성'에 대한 설명으로 알맞은 것은?**
① 개념 스키마가 변경되어도 외부 스키마에 영향을 주지 않는다.
② 응용 프로그램 코드가 변경되어도 사용자는 이를 알지 못한다.
③ 내부 스키마(저장 장치, 인덱스 등)가 변경되어도 개념 스키마나 외부 스키마에 영향을 주지 않는다.
④ 외부 스키마가 변경되어도 개념 스키마에 영향을 주지 않는다.

* **정답:** ③
* **힌트:** 하드디스크 교체나 인덱스 추가는 사용자의 논리적 뷰에 영향을 주지 않아야 합니다.
* **해설:** 데이터베이스의 3단계 스키마 구조 중 물리적인 저장 구조(내부 스키마)가 변경되어도 논리적 구조에 영향을 주지 않는 것을 물리적 데이터 독립성이라고 합니다. (Day 15)

**Q4. 다음 `<보기>` 중 엔터티(Entity) 성립을 위한 필수 조건으로 옳은 것을 모두 고르시오.**

> **<보기>**
> a. 반드시 1개 이상의 인스턴스(데이터 행)를 가져야 한다.
> b. 유일함을 보장할 수 있는 식별자(PK)를 가져야 한다.
> c. 다른 엔터티와 반드시 1개 이상의 관계가 성립해야 한다. (통계성/코드성 예외)
> d. 실제 업무 프로세스(조회, 수정 등)에 의해 이용되어야 한다.

① a, b
② b, c, d
③ a, c, d
④ b, d

* **정답:** ②
* **힌트:** 데이터가 단 1개뿐이라면 굳이 테이블로 설계할 이유가 없습니다.
* **해설:** 엔터티는 반드시 '2개 이상'의 인스턴스들의 집합이어야 성립합니다. 따라서 a는 틀린 설명입니다. (Day 16)

**Q5. 다음 중 '중심(Main) 엔터티'에 대한 설명으로 옳은 것은?**
① 업무에 원래 존재하는 가장 독립적인 엔터티이다.
② 데이터 양이 가장 많고 내용이 수시로 변경된다.
③ 기본 엔터티로부터 발생하며, 행위 엔터티를 생성하는 역할을 한다.
④ 물리적인 형태가 존재하는 엔터티를 총칭한다.

* **정답:** ③
* **힌트:** 기본과 행위의 중간에서 다리 역할을 하는 엔터티(예: 주문, 계약)입니다.
* **해설:** 기본 엔터티(고객)로부터 발생하며 또 다른 행위 엔터티(주문내역)를 파생시키는 중심 역할을 합니다. (Day 16)

**Q6. 속성(Attribute)의 특성에 따른 분류 중, 사원번호나 상품코드처럼 업무 관리를 위해 인위적으로 부여한 속성은?**
① 기본 속성 (Basic)
② 파생 속성 (Derived)
③ 설계 속성 (Designed)
④ 복합 속성 (Composite)

* **정답:** ③
* **힌트:** 원래 존재하던 것이 아니라 시스템 설계를 위해 새로 만든 것입니다.
* **해설:** 식별을 용이하게 하기 위해 인위적으로 코드를 부여하거나 새로 만든 속성을 설계 속성이라고 합니다. (Day 16)

**Q7. 다음 중 인조(대리) 식별자를 도출하는 기준으로 부적절한 것은?**
① 주식별자가 너무 많은 속성으로 구성된 복합 식별자일 때
② 업무적으로 원래 존재하는 속성을 주식별자로 쓰고 싶을 때
③ 시스템의 성능 향상을 위해 일련번호가 필요할 때
④ 주식별자의 구조가 변경될 가능성이 높을 때

* **정답:** ②
* **힌트:** 업무적으로 원래 존재하는 속성은 '본질 식별자'입니다.
* **해설:** 인조 식별자(일련번호 등)는 본질 식별자를 사용하기 복잡하거나 불편할 때 인위적으로 대체하기 위해 만듭니다. (Day 17)

**Q8. 주식별자의 4대 특징 [유.최.불.존] 중 "식별자 값은 한 번 정해지면 바뀌지 않아야 한다"를 의미하는 것은?**
① 유일성
② 최소성
③ 불변성
④ 존재성

* **정답:** ③
* **힌트:** 값이 변하지 않는다는 단어의 의미를 생각해보세요.
* **해설:** 불변성은 지정된 식별자 값이 변경되어서는 안 된다는 원칙입니다. (Day 17)

**Q9. ERD 표기법에서 식별자 관계(Solid Line)와 비식별자 관계(Dashed Line)에 대한 설명 중 옳은 것은?**
① 비식별자 관계는 부모 없이 자식이 존재할 수 없는 강한 연결이다.
② 식별자 관계가 많아지면 자식 엔터티의 주식별자 속성 수가 계속 늘어난다.
③ 비식별자 관계를 사용하면 SQL 작성 시 조인(Join)의 횟수가 항상 줄어든다.
④ 생명주기가 완전히 일치할 때는 비식별자 관계를 권장한다.

* **정답:** ②
* **힌트:** 식별자 관계는 부모의 PK를 자식의 PK로 계속 가져옵니다.
* **해설:** 식별자 관계(실선)는 부모의 주식별자를 자식의 주식별자로 상속하므로, 계층이 깊어질수록 자식의 PK 개수가 누적되어 늘어납니다. (Day 17, 20)

**Q10. 데이터 모델링에서 정규화(Normalization)를 수행하는 가장 근본적인 목적은 무엇인가?**
① 테이블 간의 조인(JOIN)을 최소화하여 조회 성능을 극대화하기 위해
② 데이터의 중복을 제거하여 삽입, 갱신, 삭제 시 발생하는 이상현상(Anomaly)을 방지하기 위해
③ 데이터베이스의 저장 용량을 무한대로 늘리기 위해
④ 물리 데이터 모델링 단계에서 인덱스를 효율적으로 생성하기 위해

* **정답:** ②
* **힌트:** 정규화의 핵심 키워드는 '중복 제거'와 '이상현상 방지'입니다.
* **해설:** 중복된 데이터를 최소화하여 데이터 무결성을 유지하는 것이 정규화의 본질입니다. (Day 18)

**Q11. 테이블 내에 주식별자가 '단일키(하나의 컬럼)'로 구성되어 있을 때, 원자성만 만족한다면 절대 위배할 일이 없는 정규화 단계는?**
① 제1정규화 (1NF)
② 제2정규화 (2NF)
③ 제3정규화 (3NF)
④ BCNF

* **정답:** ②
* **힌트:** '부분' 함수 종속은 PK가 복합키(여러 개)일 때만 발생합니다.
* **해설:** 2NF의 대상이 되는 부분 함수 종속은 주식별자가 2개 이상의 속성으로 묶인 복합키일 때만 성립합니다. (Day 18)

**Q12. 제3정규화(3NF)를 수행하기 위한 전제 조건이자, 3NF에서 제거하는 종속성은 무엇인가?**
① 2NF 만족, 다치 종속 제거
② 1NF 만족, 부분 함수 종속 제거
③ 2NF 만족, 이행적 함수 종속 제거
④ BCNF 만족, 이행적 함수 종속 제거

* **정답:** ③
* **힌트:** A -> B -> C 처럼 일반 속성끼리 꼬리를 무는 관계를 끊어내는 것입니다.
* **해설:** 3NF는 제2정규형을 만족한 상태에서 주식별자가 아닌 일반 속성 간의 이행적 함수 종속성을 제거하는 과정입니다. (Day 18)

**Q13. 정규화를 진행하여 아래와 같이 테이블이 쪼개졌다. 어떤 정규화를 수행한 것인가?**

> [변경 전] `사번(PK) -> 부서코드 -> 부서명`
> [변경 후] `사번(PK) -> 부서코드(FK)` / `부서코드(PK) -> 부서명`

① 제1정규화 (1NF)
② 제2정규화 (2NF)
③ 제3정규화 (3NF)
④ BCNF

* **정답:** ③
* **힌트:** 일반 속성인 부서코드가 부서명을 결정하는 종속을 분리했습니다.
* **해설:** 일반 속성 간의 이행적 함수 종속을 분리했으므로 제3정규화입니다. (Day 18)

**Q14. 반정규화(De-Normalization)에 대한 설명으로 올바른 것은?**
① 논리 모델링 단계에서 가장 먼저 수행해야 하는 필수 작업이다.
② 데이터 중복을 없애기 위해 테이블을 지속적으로 쪼개는 작업이다.
③ 조회(SELECT) 성능 향상을 위해 데이터 중복을 허용하고 테이블을 병합하는 과정이다.
④ 삽입/수정/삭제 성능을 높이기 위한 기법이다.

* **정답:** ③
* **힌트:** 너무 잘게 쪼개진 테이블(정규화) 때문에 JOIN이 많아져 느려질 때 쓰는 최후의 수단입니다.
* **해설:** 시스템 성능 향상과 쿼리 단순화를 위해 의도적으로 정규화 원칙을 위배하는 기법입니다. (Day 18)

**Q15. 다음 중 관계(Relationship)의 표기법인 'Crow's Foot' 기호 해석으로 부적절한 것은?**
① 기호 'O'가 표시된 쪽은 해당 엔터티의 참여가 필수적임을 의미한다.
② 기호 '<' (까마귀발) 모양은 1:N 관계에서 'Many(다수)' 쪽을 나타낸다.
③ 관계명은 현재형 동사로 기술한다.
④ 선의 안쪽 기호(| 또는 O)는 필수/선택 참여를 나타낸다.

* **정답:** ①
* **힌트:** 기호 'O'는 숫자 '0'이라고 생각하시면 됩니다. (없어도 됨)
* **해설:** 원(O) 기호는 '선택적 참여(Optional)'를 의미하며, 필수적 참여는 직선(|)으로 표시합니다. (Day 20)

---

## [제2과목] SQL 기본 및 활용 (Q16 ~ Q50)

**Q16. SQL 문장의 논리적 실행 순서(Logical Execution Order)를 올바르게 나열한 것은?**
① SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY
② FROM → SELECT → WHERE → GROUP BY → HAVING → ORDER BY
③ FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY
④ FROM → WHERE → GROUP BY → SELECT → HAVING → ORDER BY

* **정답:** ③
* **힌트:** 대상 테이블을 먼저 식별하고 필터링과 그룹화를 거친 후, 출력할 항목을 선택하고 마지막으로 정렬을 수행합니다.
* **해설:** 데이터를 가져올 대상 테이블을 지정하고(FROM), 조건을 필터링하며(WHERE), 데이터를 그룹화하고(GROUP BY, HAVING), 출력할 컬럼을 정의한 뒤(SELECT), 최종적으로 정렬(ORDER BY)합니다.

**Q17. 다음 중 NULL 처리와 관련된 설명으로 가장 적절하지 않은 것은?**
① NULL과 숫자의 산술 연산 결과는 항상 NULL이다.
② `WHERE COMM = NULL`을 사용하여 값이 비어있는지 조회할 수 있다.
③ `NVL(A, B)`는 A가 NULL이면 B를 반환한다.
④ 집계 함수 중 `COUNT(*)`는 NULL 값이 포함된 행도 계산에 포함한다.

* **정답:** ②
* **힌트:** NULL은 '상태'이므로 비교 연산자(=)를 쓸 수 없습니다.
* **해설:** NULL 값의 비교는 반드시 `IS NULL` 또는 `IS NOT NULL` 연산자를 사용해야 합니다. (Day 2, Day 19)

**Q18. `SELECT NVL2(COMM, '수당있음', '수당없음') FROM EMP;` 의 동작 방식으로 옳은 것은?**
① COMM이 NULL이면 '수당있음', 아니면 '수당없음'
② COMM이 NULL이 아니면 '수당있음', NULL이면 '수당없음'
③ COMM이 '수당있음'과 같으면 '수당없음'을 반환
④ COMM이 NULL인 경우만 '수당있음' 반환

* **정답:** ②
* **힌트:** NVL2(대상, NOT_NULL일때, NULL일때) 순서입니다.
* **해설:** NVL2는 인자 1이 NULL이 아니면 인자 2를, NULL이면 인자 3을 반환합니다. (Day 7)

**Q19. `WHERE ENAME LIKE '_A%'` 조건에 맞는 데이터는?**
① APPLE
② BANANA
③ COAT
④ ALARM

* **정답:** ②
* **힌트:** `_`는 딱 한 글자를 의미합니다. 즉, 두 번째 글자가 'A'여야 합니다.
* **해설:** 맨 앞에 한 글자(_)가 오고 두 번째가 A, 그 뒤는 상관없음(%)을 의미합니다. BANANA가 조건에 맞습니다. (Day 7)

**Q20. `WHERE 1=1` 조건이 실무에서 자주 사용되는 주된 이유는?**
① 무조건 참이 되어 모든 행을 출력하기 위해
② 쿼리 속도를 비약적으로 향상시키기 위해
③ 동적 쿼리 작성 시 AND 조건을 편하게 이어 붙이기 위해
④ 항상 FALSE를 리턴하여 빈 테이블 구조만 복사하기 위해

* **정답:** ③
* **힌트:** 유연한 조건문 뼈대를 잡기 위함입니다.
* **해설:** 항상 참이 되는 기본 조건을 깔아두면 프로그램 코드에서 `AND 조건`을 추가하거나 뺄 때 쿼리 문법이 깨지지 않아 매우 편리합니다. (Day 2, Day 7)

**Q21. 트랜잭션의 4대 특성(ACID) 중 "트랜잭션 중 발생한 오류가 없다면, 성공적으로 커밋된 데이터는 영구적으로 보존되어야 한다"는 특성은?**
① 원자성(Atomicity)
② 일관성(Consistency)
③ 고립성(Isolation)
④ 지속성(Durability)

* **정답:** ④
* **힌트:** 변치 않고 지속된다(Durable)는 의미입니다.
* **해설:** 성공적으로 완료된 트랜잭션의 결과는 시스템 장애가 발생하더라도 영구적으로 보존되어야 하는 '지속성'입니다. (Day 13, Day 19)

**Q22. Oracle 환경에서 다음 일련의 트랜잭션 스크립트를 실행한 후, 테이블에 최종 저장되는 데이터는 무엇인가?**

```sql
INSERT INTO TEST_TB VALUES (10);
SAVEPOINT SP1;
INSERT INTO TEST_TB VALUES (20);
ROLLBACK TO SP1;
INSERT INTO TEST_TB VALUES (30);
COMMIT;

```

① 10
② 10, 20, 30
③ 10, 30
④ 30

* **정답:** ③
* **힌트:** `ROLLBACK TO SP1`은 SP1 이후의 작업(20 삽입)만 취소합니다.
* **해설:** 10을 넣고 SP1 저장점을 만든 뒤, 20을 넣었다가 SP1으로 롤백하여 20은 취소됩니다. 이후 30을 넣고 커밋하므로 10과 30이 남습니다. (Day 19)

**Q23. DDL과 DML에 대한 설명으로 틀린 것은?**
① `DELETE`는 DML이므로 ROLLBACK이 가능하다.
② `TRUNCATE`는 데이터를 지우지만 DDL이므로 ROLLBACK이 불가능하다.
③ Oracle에서 DDL 문장이 수행되면 이전의 DML 작업들도 자동으로 COMMIT 된다.
④ `DROP`은 테이블 데이터만 지우고 테이블 구조(껍데기)는 남겨둔다.

* **정답:** ④
* **힌트:** 테이블 아예 통째로 날려버리는 강력한 명령어입니다.
* **해설:** `DROP`은 테이블의 구조와 데이터 모두를 데이터베이스에서 완전히 삭제합니다. 구조만 남기는 것은 `TRUNCATE` 또는 `DELETE`입니다. (Day 13)

**Q24. 다음 중 집계 연산 시 NULL 값을 어떻게 처리하는지 설명한 것으로 올바른 것은?**
① `SUM(COL)`은 COL의 NULL 값을 0으로 치환하여 계산한다.
② `AVG(COL)`은 NULL인 행도 전체 개수(분모)에 포함하여 평균을 낸다.
③ `COUNT(*)`는 NULL 값을 포함한 테이블의 전체 행 수를 센다.
④ `MAX(COL)`은 NULL과 비교하여 항상 NULL을 반환한다.

* **정답:** ③
* **힌트:** 아스테리스크(*)는 특정 컬럼이 아닌 '행 자체'의 존재를 셉니다.
* **해설:** 다른 모든 집계 함수는 NULL을 제외(무시)하고 계산하지만, `COUNT(*)`는 전체 행의 개수를 셉니다. (Day 4, Day 19)

**Q25. `UNION`과 `UNION ALL` 연산자에 대한 설명으로 가장 적절한 것은?**
① `UNION`은 두 집합의 중복을 포함하여 모두 출력한다.
② `UNION ALL`은 중복을 제거하기 위해 내부적으로 정렬(Sort)을 수행한다.
③ 성능(속도) 면에서는 정렬 연산이 없는 `UNION ALL`이 `UNION`보다 훨씬 유리하다.
④ 교집합을 구하고 싶을 때 `UNION`을 사용한다.

* **정답:** ③
* **힌트:** 중복 확인 절차의 유무가 성능 차이를 만듭니다.
* **해설:** UNION은 중복 제거를 위해 데이터 정렬 작업이 발생하지만, UNION ALL은 두 집합을 그대로 병합하기만 하므로 처리 속도가 더 빠릅니다. 교집합은 INTERSECT 연산자를 사용합니다.

**Q26. `GROUP BY ROLLUP(DEPTNO, JOB)` 실행 시 생성되는 소계의 조합으로 옳은 것은?**
① (DEPTNO, JOB), (DEPTNO), () 전체 총계
② (DEPTNO, JOB), (JOB), () 전체 총계
③ (DEPTNO), (JOB), () 전체 총계
④ (DEPTNO, JOB) 만 생성

* **정답:** ①
* **힌트:** 오른쪽 끝에서부터 하나씩 괄호 안의 요소를 지워나간다고 생각하세요.
* **해설:** ROLLUP은 계층적인 소계를 산출합니다. (A,B) → (A) → () 형태로 묶입니다. (Day 9)

**Q27. 결합 가능한 모든 경우의 수(다차원 집계)를 구하여 소계와 총계를 내는 그룹 함수는 무엇인가?**
① ROLLUP
② CUBE
③ GROUPING SETS
④ ROW_NUMBER

* **정답:** ②
* **힌트:** 3차원 정육면체처럼 모든 조합을 다 집계합니다.
* **해설:** CUBE 함수는 주어진 컬럼으로 생성 가능한 모든 조합에 대해 집계를 수행합니다. (Day 9)

**Q28. 다음 `GROUPING(DEPTNO)` 함수의 결과가 1로 나왔을 때의 의미는?**
① DEPTNO 컬럼에 1이라는 값이 들어있다.
② 그룹핑 연산 중에 발생한 에러 코드이다.
③ 해당 행은 ROLLUP/CUBE 등으로 인해 생성된 소계/총계(집계용) 행이다.
④ 실제 데이터베이스에 NULL 값이 저장되어 있다는 뜻이다.

* **정답:** ③
* **힌트:** 시스템이 소계나 총계를 계산하기 위해 임의로 생성한 행임을 식별하는 값입니다.
* **해설:** GROUPING 함수는 인자로 받은 컬럼이 ROLLUP, CUBE 등의 그룹 연산에 의해 소계 또는 총계를 산출할 목적으로 생성된 (NULL 값이 부여된) 집계 행인지 여부를 1(True)과 0(False)으로 판별합니다.

**Q29. 윈도우 함수에서 동일한 값이 있을 때 순위를 건너뛰지 않고 1등, 1등, 2등 순으로 순차적인 번호를 부여하는 함수는?**
① RANK
② DENSE_RANK
③ ROW_NUMBER
④ NTILE

* **정답:** ②
* **힌트:** 순위 사이에 공백 없이 연속된 값을 부여하는 함수입니다.
* **해설:** DENSE_RANK는 공동 순위가 존재하더라도 다음 순위 값을 건너뛰지 않고 연속적으로 매깁니다. 반면 RANK는 공동 순위만큼 값을 건너뛰며(1위, 1위, 3위), ROW_NUMBER는 고유한 순차 번호(1위, 2위, 3위)를 부여합니다.

**Q30. 윈도우 함수 내부에서 파티션별 누적 합계를 구하기 위해 "처음부터 현재 행까지"의 범위를 지정하는 구문은?**
① ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
② ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
③ ORDER BY CURRENT ROW
④ PARTITION BY UNBOUNDED PRECEDING

* **정답:** ①
* **힌트:** 한계가 없는(Unbounded) 이전(Preceding)부터 지금(Current)까지.
* **해설:** `UNBOUNDED PRECEDING`은 파티션의 첫 번째 행을 의미하며 누적 계산 시 필수적으로 사용되는 범위 지정자입니다. (Day 10)

**Q31. 현재 행을 기준으로 바로 이전 행의 데이터를 가져오는 윈도우 함수는?**
① LEAD
② LAG
③ FIRST_VALUE
④ CUME_DIST

* **정답:** ②
* **힌트:** 영단어의 의미상 지연(이전)을 뜻하는 함수를 찾으세요
* **해설:** `LAG`는 이전 행의 값을, `LEAD`는 이후 행의 값을 참조하는 함수입니다. (Day 10)

**Q32. 서브쿼리(Subquery)에 대한 설명으로 가장 부적절한 것은?**
① SELECT 절에 쓰이는 서브쿼리를 '스칼라 서브쿼리'라 하며 반드시 단일 값을 반환해야 한다.
② FROM 절에 사용되는 서브쿼리는 '인라인 뷰'라고 부른다.
③ 메인 쿼리는 서브쿼리의 내부에 있는 컬럼을 자유롭게 가져다 쓸 수 있다.
④ 서브쿼리 내에서는 원칙적으로 ORDER BY 절을 사용할 수 없다. (인라인 뷰의 TOP-N 추출 예외 제외)

* **정답:** ③
* **힌트:** 메인 쿼리는 서브쿼리 내부의 요소에 직접 접근할 수 없습니다.
* **해설:** 서브쿼리는 메인 쿼리의 컬럼을 참조할 수 있으나, 메인 쿼리는 서브쿼리에서 명시적으로 SELECT 하지 않은 내부 컬럼을 직접 참조할 수 없습니다.

**Q33. 다음 중 다중 행 서브쿼리 연산자로, 서브쿼리의 결과 중 "가장 큰 값보다 큰 것"을 찾을 때 사용하는 연산자는?**
① `> ANY`
② `> ALL`
③ `< ALL`
④ `IN`

* **정답:** ②
* **힌트:** "모든(ALL) 사람보다 키가 커야 해!"
* **해설:** `> ALL`은 서브쿼리 결과의 모든 값보다 커야 하므로 최댓값보다 커야 한다는 의미입니다. `> ANY`는 최솟값보다 크면 됩니다. (Day 8)

**Q34. 뷰(View)에 대한 설명으로 틀린 것은?**
① 실제 데이터를 물리적으로 별도 저장 공간에 복사해 두는 객체이다.
② 사용자에게 민감한 컬럼을 숨겨 보안성을 제공한다.
③ 테이블 구조가 바뀌어도 뷰 정의만 수정하면 응용 프로그램은 영향을 덜 받는다 (독립성).
④ 복잡한 JOIN 쿼리를 뷰로 저장하여 단순하게 호출할 수 있다.

* **정답:** ①
* **힌트:** 뷰는 거울과 같습니다.
* **해설:** 뷰는 '가상 테이블'로 쿼리문(정의)만 저장하며, 물리적인 실제 데이터는 원본 테이블에만 존재합니다. (Day 8)

**Q35. 다음 구문을 실행했을 때 아무런 결과(0건)도 나오지 않는 가장 전형적인 원인은 무엇인가?**
`SELECT * FROM EMP WHERE MGR NOT IN (SELECT MGR FROM DEPT);`
① 서브쿼리 결과에 중복된 MGR 값이 존재할 때
② 서브쿼리의 결과 집합에 NULL 값이 포함되어 있을 때
③ 외부 조인(OUTER JOIN)을 명시하지 않았을 때
④ IN 연산자를 썼기 때문

* **정답:** ②
* **힌트:** NOT IN 연산자는 하나라도 조건이 거짓(UNKNOWN)이면 전체를 거짓으로 평가합니다.
* **해설:** NOT IN 연산 수행 시 서브쿼리의 반환 결과에 NULL 값이 하나라도 포함되어 있으면, 논리 연산의 결과가 UNKNOWN이 되어 메인 쿼리는 어떠한 행도 반환하지 않습니다.

**Q36. 행(Row)으로 길게 나열된 데이터(Long Data)를 열(Column)로 변환하여 가로로 넓은(Wide Data) 요약 보고서를 만들 때 사용하는 구문은?**
① CROSS JOIN
② PIVOT
③ UNPIVOT
④ ROLLUP

* **정답:** ②
* **힌트:** 엑셀의 '그 기능' 이름과 동일합니다.
* **해설:** `PIVOT`은 행을 열로 회전시키며 동시에 집계 함수(SUM, COUNT 등)를 적용하여 크로스탭 보고서를 생성합니다. (Day 12)

**Q37. 오라클의 계층형 질의(Hierarchical Query)에서 트리의 시작(루트) 노드를 지정하는 구문은?**
① CONNECT BY
② PRIOR
③ START WITH
④ ORDER SIBLINGS BY

* **정답:** ③
* **힌트:** "누구부터 시작(Start)할까?"
* **해설:** `START WITH` 구문을 통해 계층 전개의 기준점(루트 노드) 조건을 지정합니다. (Day 11)

**Q38. 계층형 질의에서 자식이 없는 말단(Leaf) 노드인지를 판별하여 1 또는 0을 반환하는 가상 컬럼은?**
① LEVEL
② CONNECT_BY_ISLEAF
③ SYS_CONNECT_BY_PATH
④ ROWNUM

* **정답:** ②
* **힌트:** 트리 구조에서 단말 노드(말단)를 의미하는 단어가 포함되어 있습니다.
* **해설:** 트리의 가장 하단에 위치하여 하위 노드가 없는 경우 CONNECT_BY_ISLEAF의 값이 1로 반환됩니다. LEVEL은 해당 노드의 계층 깊이를 나타냅니다.

**Q39. 오라클 환경에서 상위 3명의 사원을 조회하기 위해 가장 알맞은 쿼리는?**
① `SELECT * FROM EMP WHERE ROWNUM <= 3 ORDER BY SAL DESC;`
② `SELECT * FROM (SELECT * FROM EMP ORDER BY SAL DESC) WHERE ROWNUM <= 3;`
③ `SELECT TOP(3) * FROM EMP ORDER BY SAL DESC;`
④ `SELECT * FROM EMP ORDER BY SAL DESC LIMIT 3;`

* **정답:** ②
* **힌트:** ROWNUM은 데이터가 추출되는 시점에 부여되므로 정렬 작업보다 우선하여 실행됩니다.
* **해설:** 오라클에서 `ROWNUM`은 `ORDER BY`보다 먼저 실행되므로, 서브쿼리(인라인 뷰) 안에서 먼저 정렬(ORDER BY)을 마친 후 밖에서 ROWNUM을 잘라내야 정확한 상위 N개를 구할 수 있습니다. (Day 11)

**Q40. 셀프 조인(Self Join) 시 반드시 지켜야 하는 필수 작성 규칙은?**
① `OUTER JOIN`을 반드시 사용해야 한다.
② 동일한 테이블을 두 번 부르므로, 구분을 위해 테이블 별칭(Alias)을 다르게 지정해야 한다.
③ 조건절에 서브쿼리를 꼭 넣어야 한다.
④ `UNION`으로 합쳐야 한다.

* **정답:** ②
* **힌트:** 데이터베이스 엔진이 동일한 테이블의 두 인스턴스를 논리적으로 구분할 수 있어야 합니다.
* **해설:** FROM 절에 동일한 테이블이 여러 번 명시되므로, EMP E1 JOIN EMP E2와 같이 서로 다른 테이블 별칭(Alias)을 부여하여 객체의 모호성을 해소해야 합니다.

**Q41. INNER JOIN과 LEFT OUTER JOIN의 가장 큰 차이점은 무엇인가?**
① INNER JOIN은 교집합만 출력하고, LEFT OUTER JOIN은 왼쪽 테이블의 짝없는 데이터도 NULL을 덧붙여 모두 출력한다.
② INNER JOIN은 조인 조건이 필요 없고 LEFT JOIN은 필요하다.
③ INNER JOIN은 두 테이블의 합집합을 구한다.
④ LEFT JOIN은 외부 식별자(FK)가 없을 때만 사용 가능하다.

* **정답:** ①
* **힌트:** OUTER JOIN은 기준 테이블의 데이터를 보존하는 데 목적이 있습니다.
* **해설:** 내부 조인(INNER JOIN)은 양쪽 테이블 모두에 조건이 일치하는 데이터만 반환합니다. 반면 외부 조인(LEFT OUTER JOIN)은 왼쪽 테이블의 데이터를 모두 출력하며, 오른쪽 테이블에서 조건에 매칭되지 않는 항목은 NULL 값으로 채워 반환합니다.

**Q42. 오라클 전용 조인 문법에서 `WHERE A.DEPTNO = B.DEPTNO(+)` 가 의미하는 조인 방식은?**
① FULL OUTER JOIN
② INNER JOIN
③ A 테이블 기준 LEFT OUTER JOIN
④ B 테이블 기준 RIGHT OUTER JOIN

* **정답:** ③
* **힌트:** (+) 기호는 조인할 데이터가 존재하지 않아 NULL 값이 보충될 테이블 측에 위치합니다.
* **해설:** 오라클 외부 조인 구문에서 (+) 기호는 정보가 부족하여 NULL이 생성되는 반대쪽(기준이 아닌 쪽)에 기술합니다. B 테이블 측에 기호가 있으므로 A 테이블의 모든 데이터가 출력되는 LEFT OUTER JOIN을 의미합니다.

**Q43. 두 테이블 사이에 조인 조건(`WHERE`나 `ON` 절)을 아예 생략하고 SELECT를 수행했을 때 발생하는 현상은?**
① 에러가 발생하여 쿼리가 멈춘다.
② 두 테이블의 데이터가 수직으로 이어 붙는 합집합이 된다.
③ 두 테이블의 모든 행이 가능한 모든 조합으로 곱해지는 CROSS JOIN(카티션 곱)이 발생한다.
④ 무작위로 한 테이블의 데이터만 출력된다.

* **정답:** ③
* **힌트:** 연결 고리가 없으면 시스템은 '모든 경우의 수'를 다 만들어버립니다.
* **해설:** 조인 조건이 누락되면 M행 * N행 건수의 무수한 데이터 조합이 폭발적으로 출력됩니다. (Day 5)

**Q44. 정규표현식(Regular Expression)에서 문자열의 '시작'과 '끝'을 의미하는 메타 문자로 바르게 짝지어진 것은?**
① `*` 와 `+`
② `^` 와 `$`
③ `?` 와 `.`
④ `\` 와 `/`

* **정답:** ②
* **힌트:** 정규식 패턴 지정 시 시작 앵커와 종료 앵커 역할을 하는 기호입니다.
* **해설:** `정규표현식에서 ^ 메타 문자는 문자열 패턴의 시작 위치를, $ 메타 문자는 문자열 패턴의 종료 위치를 명시할 때 사용됩니다.

**Q45. `REGEXP_SUBSTR('A123B45', '\d+')` 의 추출 결과로 알맞은 것은?**
① A
② 123
③ B
④ 123B45

* **정답:** ②
* **힌트:** `\d`는 숫자, `+`는 1개 이상 연속됨을 뜻합니다.
* **해설:** 정규식 함수는 매칭되는 첫 번째 덩어리를 추출합니다. 숫자 덩어리인 '123'이 반환됩니다. (Day 12)

**Q46. 다음 중 조건에 따라 `INSERT`와 `UPDATE` (필요시 DELETE 포함) 작업을 한 번에 수행할 수 있는 활용도 높은 DML 명령어는?**
① GRANT
② TRUNCATE
③ MERGE
④ ROLLUP

* **정답:** ③
* **힌트:** 데이터가 타겟에 이미 있으면 업데이트하고, 없으면 새로 넣는 '병합' 명령어입니다.
* **해설:** `MERGE INTO` 구문은 조건(`ON`)의 매치 여부에 따라 `WHEN MATCHED THEN UPDATE`, `WHEN NOT MATCHED THEN INSERT`를 수행합니다. (Day 13)

**Q47. 다른 테이블에서 외래키(FK)로 참고하고 있는 부모 테이블(DEPT)을 강제로 완전히 삭제하고 싶을 때 사용하는 옵션은?**
① `DROP TABLE DEPT FORCE;`
② `DELETE TABLE DEPT CASCADE;`
③ `DROP TABLE DEPT CASCADE CONSTRAINTS;`
④ `TRUNCATE TABLE DEPT ALL;`

* **정답:** ③
* **힌트:** 참조 무결성 제약조건을 연쇄적으로 해제하는 키워드가 포함되어 있습니다.
* **해설:** 자식 테이블이 참조하고 있어 삭제가 불가능한 부모 테이블을 지우려면, 연결된 참조 제약조건(Constraints)을 함께 제거하는 CASCADE CONSTRAINTS 옵션을 명시해야 합니다.

**Q48. `MERGE INTO` 문 내에서 `DELETE WHERE` 구문을 사용할 때의 특징으로 옳은 것은?**
① 원본(Source) 테이블의 조건에 맞는 데이터를 지운다.
② 전체 타겟 테이블에서 조건에 맞는 데이터를 지운다.
③ `UPDATE` 조건절에 의해 매치되어 실제로 갱신 작업이 일어난 행들 중에서만 필터링하여 삭제한다.
④ 조건 매치 여부와 상관없이 무조건 마지막에 실행된다.

* **정답:** ③
* **힌트:** 병합 중 갱신(Update)의 터치를 받은 녀석들만 삭제 대상이 됩니다.
* **해설:** MERGE 문에 딸린 DELETE는 타겟 테이블 전체가 아니라, 오직 `UPDATE`의 영향을 받은 행(Matched) 내에서만 평가되어 동작하는 독특한 특징이 있습니다. (Day 13)

**Q49. DCL 명령어 중 다수의 권한을 하나로 묶어 사용자에게 일괄 부여하기 위해 사용하는 권한들의 묶음은?**
① VIEW
② INDEX
③ SAVEPOINT
④ ROLE

* **정답:** ④
* **힌트:** 데이터베이스 보안 권한을 직무나 역할 단위로 묶어 관리하는 단위입니다.
* **해설:** ROLE은 개별적인 시스템 권한이나 객체 권한들을 하나의 세트로 묶어놓은 권한 집합체로, 여러 사용자에게 효율적으로 권한을 관리하고 부여하기 위해 사용됩니다.

**Q50. `NVL(100 + NULL, 50)`의 결과 값으로 올바른 것은?**
① 150
② 100
③ 50
④ NULL

* **정답:** ③
* **힌트:** `100 + NULL`의 결과가 무엇인지 먼저 계산하세요.
* **해설:** 산술 연산인 `100 + NULL`의 결과는 무조건 `NULL`입니다. 따라서 수식이 `NVL(NULL, 50)`으로 치환되며, 최종적으로 50을 반환합니다. (Day 14)