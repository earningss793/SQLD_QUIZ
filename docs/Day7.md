
---

### [Part 1] SELECT, WHERE, 연산자 (1~10번)

**1. 다음 중 SQL 문장의 실행 순서로 올바른 것은?**

* 1. SELECT - FROM - WHERE - ORDER BY


* 2. FROM - WHERE - SELECT - ORDER BY


* 3. FROM - SELECT - WHERE - ORDER BY


* 4. WHERE - FROM - SELECT - ORDER BY


* **정답:** 2)
* **해설:** 데이터베이스는 먼저 테이블을 찾고(FROM), 조건에 맞는 행을 걸러낸 뒤(WHERE), 보여줄 컬럼을 선택하고(SELECT), 마지막으로 정렬(ORDER BY)합니다.
* **힌트:** "어디서(FROM) 가져와서, 어떻게 거르고(WHERE), 뭘 보여줄지(SELECT)" 순서입니다.

**2. 다음 중 별칭(Alias) 사용 시 오류가 발생하는 경우는?**

* 1. `SELECT NAME AS 이름 FROM USER;`


* 2. `SELECT NAME 이름 FROM USER;`


* 3. `SELECT NAME "내 이름" FROM USER;`


* 4. `SELECT NAME '이름' FROM USER;`


* **정답:** 4)
* **해설:** 별칭에 공백이 있거나 특수문자가 있을 때는 반드시 큰따옴표(" ")를 써야 합니다. 작은따옴표(' ')는 문자열 값을 의미할 때 씁니다.
* **힌트:** 이름표(Alias)는 크게(") 붙이세요!

**3. [테이블: TB1]에 데이터 (100, NULL, 50)이 있을 때 `SELECT SUM(COL1 + 10) FROM TB1;`의 결과는?**

* 1. 180


* 2. 160


* 3. 170


* 4. NULL


* **정답:** 3)
* **해설:** 행 단위 연산 `(100+10), (NULL+10), (50+10)`의 결과는 `110, NULL, 60`입니다. `SUM`은 NULL을 제외하고 계산하므로 이 됩니다.
* **힌트:** NULL과 숫자를 더하면 무조건 NULL입니다.

**4. `WHERE NAME LIKE '_A%'` 조건에 맞는 데이터는?**

* 1. APPLE


* 2. BANANA


* 3. COAT


* 4. ALARM


* **정답:** 2)
* **해설:** `_`는 딱 한 글자를 의미하고 그 다음이 `A`여야 하므로, 두 번째 글자가 'A'인 단어를 찾습니다.
* **힌트:** 밑줄 하나당 한 글자입니다.

**5. 다음 중 NULL인 값을 조회하고자 할 때 올바른 조건식은?**

* 1. `WHERE COMM = NULL`


* 2. `WHERE COMM IS NULL`


* 3. `WHERE COMM == NULL`


* 4. `WHERE COMM IS NOT NULL`


* **정답:** 2)
* **해설:** NULL은 값이 아니므로 `=` 연산자로 비교할 수 없으며 반드시 `IS NULL`을 사용해야 합니다.
* **힌트:** 비어있는지 물어볼 때는 전용 단어를 씁니다.

**6. `BETWEEN 10 AND 20` 조건과 동일한 의미를 가진 조건식은?**

* 1. `COL > 10 AND COL < 20`


* 2. `COL >= 10 OR COL <= 20`


* 3. `COL >= 10 AND COL <= 20`


* 4. `COL > 10 OR COL < 20`


* **정답:** 3)
* **해설:** `BETWEEN`은 경계값 10과 20을 모두 포함하는 이상/이하 조건입니다.
* **힌트:** 양 끝값을 포함한다는 점이 핵심입니다.

**7. `IN (10, 20, 30)` 연산자와 동일한 결과를 내는 조건식은?**

* 1. `COL = 10 OR COL = 20 OR COL = 30`


* 2. `COL = 10 AND COL = 20 AND COL = 30`


* 3. `COL >= 10 AND COL <= 30`


* 4. `COL = 10 OR 20 OR 30`


* **정답:** 1)
* **해설:** `IN`은 나열된 값 중 하나라도 일치하면 되는 합집합(OR) 연산입니다.
* **힌트:** "이 중에 하나라도 있으면 가져와"라는 뜻입니다.

**8. `WHERE 1=1`과 같은 조건이 실무에서 자주 사용되는 주된 이유는?**

* 1. 무조건 참이 되어 모든 행을 출력하기 위해


* 2. 성능을 최적화하기 위해


* 3. 쿼리 문법 오류를 방지하고 조건을 동적으로 추가하기 편하기 위해


* 4. 인덱스를 태우기 위해


* **정답:** 3)
* **해설:** 기본 조건을 깔아두면 이후에 `AND`로 조건을 덧붙이기 매우 편리하여 실무(마케팅 타겟팅 추출 등)에서 자주 씁니다.
* **힌트:** 코드의 유연성을 위해 사용합니다.

**9. 다음 중 연산자 우선순위가 가장 높은 것은?**

* 1. OR


* 2. AND


* 3. NOT


* 4. 괄호 ()


* **정답:** 4)
* **해설:** 수학과 마찬가지로 괄호 안의 조건이 가장 먼저 처리됩니다. 논리 연산자 중에서는 `NOT > AND > OR` 순입니다.
* **힌트:** 가장 먼저 계산하고 싶은 건 괄호로 묶으세요.

**10. [테이블: TB]에 행이 10개 있을 때 `SELECT COUNT(*) FROM TB WHERE 1=2;`의 결과는?**

* 1. 0


* 2. 10


* 3. NULL


* 4. 에러 발생


* **정답:** 1)
* **해설:** `1=2`는 항상 거짓이므로 필터링되는 행이 하나도 없습니다. 행이 없으므로 `COUNT`의 결과는 0입니다.
* **힌트:** 조건이 거짓이면 아무것도 남지 않습니다.

---

### [Part 2] 단일행 함수 및 CASE (11~20번)

**11. `SELECT ROUND(123.456, 1) FROM DUAL;`의 결과는?**

* 1. 123


* 2. 123.5


* 3. 123.4


* 4. 123.46


* **정답:** 2)
* **해설:** 소수점 첫째 자리**까지** 표시하라는 의미이므로, 둘째 자리(5)에서 반올림하여 123.5가 됩니다.
* **힌트:** 지정된 자릿수까지 남긴다고 생각하세요.

**12. [이미지 유형 응용] 다음 SQL의 결과로 올바른 것은? (우선순위 주의)**
[TABLE: PROD] (NAME: 'A', PRICE: 2500)
`SELECT CASE WHEN PRICE > 1000 THEN '고가' WHEN PRICE > 2000 THEN '초고가' ELSE '일반' END FROM PROD;`

* 1. 고가


* 2. 초고가


* 3. 일반


* 4. NULL


* **정답:** 1)
* **해설:** CASE문은 **위에서부터 순차적으로** 조건을 검사하며, 첫 번째 만족하는 조건에서 멈춥니다. 2500은 1000보다 크므로 바로 '고가'를 반환합니다.
* **힌트:** 첨부이미지 12번의 핵심 함정입니다!

**13. `NVL2(COMM, '수당있음', '수당없음')`의 동작 방식으로 옳은 것은?**

* 1. COMM이 NULL이면 '수당있음', 아니면 '수당없음'


* 2. COMM이 NULL이 아니면 '수당있음', NULL이면 '수당없음'


* 3. COMM과 '수당있음'이 같으면 '수당없음' 반환


* 4. COMM이 NULL인 경우만 '수당있음' 반환


* **정답:** 2)
* **해설:** `NVL2(대상, NOT_NULL일때, NULL일때)` 순서로 작동합니다.
* **힌트:** 2번 인자가 긍정(Not Null)입니다.

**14. `SELECT LOWER('SQLD Pass') FROM DUAL;`의 결과는?**

* 1. SQLD PASS


* 2. sqld pass


* 3. Sqld Pass


* 4. sqld Pass


* **정답:** 2)
* **해설:** `LOWER` 함수는 모든 대문자를 소문자로 변환합니다.
* **힌트:** 영어 그대로 '낮춘다'는 뜻입니다.

**15. 다음 중 날짜 함수에 대한 설명으로 틀린 것은? (Oracle 기준)**

* 1. `SYSDATE`는 현재 날짜와 시간을 반환한다.


* 2. `날짜 + 1`은 해당 날짜에 1시간을 더한 결과를 반환한다.


* 3. `EXTRACT(YEAR FROM SYSDATE)`는 현재 연도를 숫자로 추출한다.


* 4. `날짜 - 날짜`의 결과는 두 날짜 사이의 일수 차이다.


* **정답:** 2)
* **해설:** 날짜에 숫자를 더하면 '일(Day)' 단위로 계산됩니다. `+ 1`은 1일(24시간)을 더하는 것입니다.
* **힌트:** 기본 단위는 '하루'입니다.

**16. `SELECT NULLIF(100, 100) FROM DUAL;`의 결과는?**

* 1. 100


* 2. 0


* 3. NULL


* 4. 에러 발생


* **정답:** 3)
* **해설:** `NULLIF(A, B)`는 두 값이 같으면 NULL을, 다르면 A를 반환합니다.
* **힌트:** "같으면 NULL로 처리해라"는 뜻입니다.

**17. `SELECT COALESCE(NULL, NULL, 'C', 'D') FROM DUAL;`의 결과는?**

* 1. NULL


* 2. 'C'


* 3. 'D'


* 4. 'C, D'


* **정답:** 2)
* **해설:** `COALESCE`는 인자 리스트 중 NULL이 아닌 첫 번째 값을 반환합니다.
* **힌트:** 비어있지 않은 첫 번째 데이터를 찾을 때 유용합니다.

**18. `SELECT CEIL(12.1), FLOOR(12.9) FROM DUAL;`의 결과로 올바른 조합은?**

* 1. 12, 12


* 2. 13, 13


* 3. 12, 13


* 4. 13, 12


* **정답:** 4)
* **해설:** `CEIL`(천장)은 올림하여 13, `FLOOR`(바닥)은 내림하여 12가 됩니다.
* **힌트:** 위(천장)를 볼지, 아래(바닥)를 볼지 생각하세요.

**19. `SELECT SUBSTR('MARKETER', 2, 3) FROM DUAL;`의 결과는?**

* 1. MAR


* 2. ARK


* 3. RKE


* 4. KET


* **정답:** 2)
* **해설:** 2번째 글자('A')부터 시작하여 3글자를 가져오므로 'ARK'가 됩니다.
* **힌트:** 시작 위치와 길이를 정확히 세어보세요.

**20. `SELECT LTRIM('  SQL  ') FROM DUAL;`의 결과는? (공백 표시 주의)**

* 1. 'SQL  '


* 2. '  SQL'


* 3. 'SQL'


* 4. ' SQL '


* **정답:** 1)
* **해설:** `LTRIM`은 왼쪽(Left)의 공백만 제거합니다. 오른쪽 공백은 남아있습니다.
* **힌트:** 어느 쪽(L/R)을 깎아낼지 결정합니다.

---

### [Part 3] GROUP BY 및 HAVING (21~30번)

**21. [이미지 유형 응용] 다음 ORDERS 테이블에 대해 SQL 실행 결과로 올바른 고객 ID는?**
[ORDERS] (ID: C01, AMT: 500 / ID: C02, AMT: 50 / ID: C01, AMT: 100)
`SELECT ID FROM ORDERS GROUP BY ID HAVING COUNT(*) >= 2 AND SUM(AMT) > 500;`

* 1. C01


* 2. C02


* 3. C01, C02 모두


* 4. 결과 없음


* **정답:** 1)
* **해설:** C01은 2건이며 합계가 600이므로 두 조건을 모두 만족합니다. C02는 1건이므로 탈락입니다.
* **힌트:** 첨부이미지 13번의 다중 조건 판별 문제입니다.

**22. `SELECT DEPTNO, SUM(SAL) FROM EMP GROUP BY DEPTNO;` 쿼리에서 GROUP BY의 역할은?**

* 1. 급여 순으로 정렬한다.


* 2. 부서별로 행을 묶어 합계를 낼 기준을 정한다.


* 3. 중복된 부서 번호를 제거하고 조회한다.


* 4. 부서 번호가 있는 행만 거른다.


* **정답:** 2)
* **해설:** 동일한 컬럼 값을 가진 데이터들을 소그룹으로 묶어 집계 함수를 적용하게 합니다.
* **힌트:** 엑셀의 피벗 테이블과 같습니다.

**23. 다음 중 HAVING 절에 대한 설명으로 올바른 것은?**

* 1. WHERE 절보다 먼저 실행된다.


* 2. 집계 함수를 사용한 조건 필터링이 가능하다.


* 3. 모든 SQL 문장에 반드시 포함되어야 한다.


* 4. 그룹화하기 전의 개별 행을 필터링한다.


* **정답:** 2)
* **해설:** HAVING은 그룹화된 이후의 집계 결과(SUM, AVG 등)를 필터링할 때 씁니다.
* **힌트:** "그룹의 조건"은 HAVING입니다.

**24. `COUNT(*)`와 `COUNT(COMM)`의 차이점으로 옳은 것은?**

* 1. 차이가 없다.


* 2. `COUNT(*)`은 NULL을 포함하고, `COUNT(COMM)`은 NULL을 제외한다.


* 3. `COUNT(*)`은 NULL을 제외하고, `COUNT(COMM)`은 NULL을 포함한다.


* 4. `COUNT(COMM)`은 중복된 값은 하나만 샌다.


* **정답:** 2)
* **해설:** 아스테리스크(`*`)는 행 자체의 개수를 세므로 NULL을 포함하지만, 컬럼명을 지정하면 해당 컬럼이 NULL인 행은 뺍니다.
* **힌트:** 컬럼을 콕 집으면 "그 안에 값이 들어있는지" 따지게 됩니다.

**25. 다음 쿼리 중 문법 오류가 발생하는 것은?**

* 1. `SELECT DEPTNO FROM EMP GROUP BY DEPTNO;`


* 2. `SELECT DEPTNO, COUNT(*) FROM EMP GROUP BY DEPTNO;`


* 3. `SELECT DEPTNO, SAL FROM EMP GROUP BY DEPTNO;`


* 4. `SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO;`


* **정답:** 3)
* **해설:** GROUP BY 절에 없는 일반 컬럼(`SAL`)을 SELECT 절에 단독으로 적을 수 없습니다.
* **힌트:** 그룹으로 묶었으면 "그 그룹의 대표값(집계)"만 보여줘야 합니다.

**26. `SELECT DEPTNO 부서, SUM(SAL) 합계 FROM EMP GROUP BY 부서;`가 오류인 이유는?**

* 1. 별칭에 한글을 썼기 때문에


* 2. GROUP BY 절에는 SELECT에서 정한 별칭을 쓸 수 없기 때문에


* 3. SUM 함수에는 별칭을 줄 수 없기 때문에


* 4. FROM 절이 마지막에 와야 하기 때문에


* **정답:** 2)
* **해설:** 실행 순서상 GROUP BY가 SELECT보다 먼저이므로, 아직 태어나지 않은 별칭을 GROUP BY가 인식할 수 없습니다.
* **힌트:** 실행 순서 "프-웨-그-하-셀-오"를 다시 떠올리세요.

**27. 다음 중 성격이 다른 집계 함수는?**

* 1. SUM


* 2. AVG


* 3. COUNT


* 4. SUBSTR


* **정답:** 4)
* **해설:** 앞의 세 개는 여러 행을 묶어 하나로 만드는 집계 함수이고, `SUBSTR`은 각 행마다 실행되는 단일행 함수입니다.
* **힌트:** "뭉치느냐, 따로 노느냐"의 차이입니다.

**28. 부서별 평균 급여가 3000 이상인 부서만 조회하고 싶을 때 적절한 구문은?**

* 1. `WHERE AVG(SAL) >= 3000`


* 2. `HAVING AVG(SAL) >= 3000`


* 3. `GROUP BY AVG(SAL) >= 3000`


* 4. `ORDER BY AVG(SAL) >= 3000`


* **정답:** 2)
* **해설:** 집계 결과에 대한 조건은 반드시 HAVING 절을 사용해야 합니다.
* **힌트:** WHERE 절에서는 집계 함수를 쓸 수 없습니다.

**29. [TB1]에 데이터 (10, 20, NULL)이 있을 때 `AVG(COL1)`의 결과는?**

* 1. 10


* 2. 15


* 3. 20


* 4. NULL


* **정답:** 2)
* **해설:** `AVG`는 NULL을 제외하므로 가 됩니다. (분모에서도 제외됨)
* **힌트:** NULL은 없는 셈 치고 남은 숫자들의 평균을 냅니다.

**30. 집계 함수 `MAX`, `MIN`이 처리할 수 있는 데이터 타입은?**

* 1. 숫자형만 가능


* 2. 숫자형과 날짜형만 가능


* 3. 숫자형, 날짜형, 문자형 모두 가능


* 4. 날짜형만 가능


* **정답:** 3)
* **해설:** 최대/최소는 숫자뿐만 아니라 가나다순(문자), 과거/미래(날짜) 모두 비교 가능합니다.
* **힌트:** "가장 큰 것과 작은 것"은 글자나 날짜에서도 정할 수 있습니다.

---

### [Part 4] JOIN 및 복합 응용 (31~40번)

**31. [이미지 유형 응용] 3개 테이블 조인 시 오류가 발생하는 주된 원인은? (첨부이미지 31, 32번 참고)**

* 1. 조인 조건을 WHERE 절에 써서


* 2. 별칭(Alias)을 부여하지 않아서


* 3. 존재하지 않는 테이블의 컬럼을 조인 조건으로 사용해서 (부적합한 식별자)


* 4. 컬럼 이름이 서로 달라서


* **정답:** 3)
* **해설:** `EMP.DEPT_ID = DEPT.DEPT_ID`와 같이 실제 테이블에 있는 컬럼끼리 매칭해야 합니다. 엉뚱한 테이블 별칭을 가져다 쓰면 '부적합한 식별자' 에러가 납니다.
* **힌트:** 별칭(e, d, l)이 어떤 테이블을 가리키는지, 그 테이블에 그 컬럼이 진짜 있는지 확인하세요.

**32. INNER JOIN에 대한 설명으로 틀린 것은?**

* 1. 두 테이블 모두에 조인 컬럼 값이 있는 행만 조회된다.


* 2. 조인 조건에 `=`(등호)를 사용하면 등가 조인(EQUI JOIN)이라 한다.


* 3. 어느 한쪽에만 데이터가 있는 경우도 출력한다.


* 4. 교집합과 같은 개념이다.


* **정답:** 3)
* **해설:** 한쪽에만 있는 데이터를 출력하는 것은 OUTER JOIN입니다. INNER JOIN은 공통된 것만 보여줍니다.
* **힌트:** "서로 마음이 맞아야만(매칭) 나온다"고 생각하세요.

**33. LEFT OUTER JOIN에서 오른쪽 테이블에 매칭되는 데이터가 없을 때 결과는?**

* 1. 결과에서 제외된다.


* 2. 에러가 발생한다.


* 3. 왼쪽 데이터만 나오고 오른쪽 데이터 자리는 NULL로 채워진다.


* 4. 왼쪽 데이터도 NULL로 나온다.


* **정답:** 3)
* **해설:** 기준이 되는 왼쪽 테이블은 무조건 다 보여주고, 짝이 없는 오른쪽은 빈칸(NULL)으로 둡니다.
* **힌트:** 마케팅 타겟(왼쪽)에게 구매 이력(오른쪽)을 붙일 때, 안 산 사람은 NULL로 뜨겠죠?

**34. 다음 중 NATURAL JOIN의 특징이 아닌 것은?**

* 1. 두 테이블에서 이름이 같은 모든 컬럼을 자동으로 조인한다.


* 2. `ON` 절을 명시적으로 사용할 수 없다.


* 3. 조인 컬럼에 테이블 별칭을 붙여서 사용해야 한다.


* 4. `USING` 절과 같이 사용할 수 없다.


* **정답:** 3)
* **해설:** NATURAL JOIN의 가장 큰 특징은 조인 컬럼에 별칭을 붙이면 오류가 난다는 점입니다.
* **힌트:** 자동으로 합쳐졌으므로 누구의 것인지 따지지 않습니다.

**35. 테이블 A(행 3개)와 테이블 B(행 5개)를 CROSS JOIN 했을 때 결과 행의 개수는?**

* 1. 3개


* 2. 5개


* 3. 8개


* 4. 15개


* **정답:** 4)
* **해설:** 모든 조합을 다 만드는 카티션 곱이므로 가 됩니다.
* **힌트:** 연결 고리가 없을 때 발생하는 '폭발적인' 결과입니다.

**36. 3개의 테이블을 조인할 때 필요한 최소 조인 조건의 개수는?**

* 1. 1개


* 2. 2개


* 3. 3개


* 4. 제한 없음


* **정답:** 2)
* **해설:** 개의 테이블을 조인하려면 최소 개의 연결 고리가 필요합니다.
* **힌트:** 다리를 몇 개 놓아야 세 섬을 이을 수 있는지 생각해보세요.

**37. 다음 중 Non-EQUI JOIN(비등가 조인)이 사용되는 사례는?**

* 1. 사원번호가 일치하는 부서명 찾기


* 2. 고객 등급 테이블에서 점수가 특정 범위(BETWEEN)에 있는 등급 가져오기


* 3. 이름이 같은 사원 목록 조회


* 4. 부서번호가 10번인 사원 조회


* **정답:** 2)
* **해설:** 등호(`=`)가 아닌 범위 연산자나 비교 연산자로 조인하는 방식입니다.
* **힌트:** "딱 맞는 값"이 아니라 "이 범위 안"인지 따질 때 씁니다.

**38. USING 절을 사용한 조인에서 주의할 점은?**

* 1. 조인 컬럼의 데이터 타입이 달라도 된다.


* 2. 조인 컬럼에 별칭을 붙이면 오류가 발생한다.


* 3. `ON` 절을 반드시 함께 써야 한다.


* 4. 서로 다른 이름의 컬럼을 묶을 때 쓴다.


* **정답:** 2)
* **해설:** `USING (DEPTNO)`와 같이 쓰며, 이 컬럼에는 테이블 별칭을 붙일 수 없습니다.
* **힌트:** NATURAL JOIN과 마찬가지로 "공통 컬럼"에 대한 매너입니다.

**39. [이미지 유형 응용] EMP(사원), DEPT(부서), LOC(위치) 3개 테이블 조인 시 올바른 순서는?**

* 1. EMP와 DEPT를 먼저 조인한 결과와 LOC를 조인한다.


* 2. 3개를 동시에 한 번에 섞는다.


* 3. LOC와 EMP를 먼저 직접 조인한다. (관계가 없어도)


* 4. 상관없으나 보통 1번처럼 순차적으로 처리된다.


* **정답:** 1)
* **해설:** 논리적으로 두 테이블을 먼저 조인하여 가상의 테이블을 만들고, 그 결과를 다음 테이블과 연결합니다.
* **힌트:** 사원은 부서에 속해 있고, 부서는 특정 위치에 있다는 연결 고리를 따라갑니다.

**40. `SELECT * FROM A, B;` (WHERE 절 없음) 쿼리의 결과는 무엇인가?**

* 1. 에러가 발생한다.


* 2. 두 테이블의 합집합이 나온다.


* 3. CROSS JOIN 결과가 나온다.


* 4. 조인 조건이 없으므로 아무것도 출력되지 않는다.


* **정답:** 3)
* **해설:** WHERE 절에 조인 조건을 명시하지 않으면 시스템은 자동으로 모든 행을 곱하는 CROSS JOIN을 수행합니다.
* **힌트:** 실수로 조건을 빼먹었을 때 마주하게 되는 데이터 폭탄입니다.


### [실전 추론 10문항]

**문항 41. [CASE문 우선순위]**
다음 `PRODUCT` 테이블을 대상으로 쿼리를 실행했을 때, 'C' 상품의 `PRICE_LEVEL`은 무엇인가?

| PRODUCT_ID | NAME | PRICE |
| --- | --- | --- |
| 101 | A | 500 |
| 102 | B | 1500 |
| 103 | C | 3000 |

**[SQL]**

```sql
SELECT NAME,
       CASE WHEN PRICE >= 1000 THEN 'Gold'
            WHEN PRICE >= 2000 THEN 'VIP'
            ELSE 'Normal'
       END AS PRICE_LEVEL
FROM PRODUCT;

```

1. Gold
2. VIP
3. Normal
4. NULL

* **정답:** 1)
* **해설:** CASE문은 만족하는 첫 번째 조건을 만나면 즉시 종료됩니다. 3000은 첫 번째 조건인 `PRICE >= 1000`을 이미 만족하므로 'Gold'를 반환하고 끝납니다. 'VIP'를 원했다면 큰 숫자 조건부터 먼저 써야 합니다.
* **힌트:** "먼저 만나는 놈이 임자"입니다.

---

**문항 42. [HAVING절 복합 필터링]**
다음 `SALES` 테이블에서 쿼리 실행 결과로 출력되는 `CATEGORY`는?

| CATEGORY | AMOUNT | COUNT |
| --- | --- | --- |
| Food | 500 | 1 |
| Food | 600 | 1 |
| App | 1200 | 1 |
| App | 100 | 1 |

**[SQL]**

```sql
SELECT CATEGORY
FROM SALES
GROUP BY CATEGORY
HAVING COUNT(*) >= 2 AND SUM(AMOUNT) > 1500;

```

1. Food
2. App
3. Food, App 모두
4. 결과 없음

* **정답:** 4)
* **해설:** `Food`는 합계가 1100이라 탈락, `App`은 합계가 1300이라 탈락입니다. 두 조건을 동시에 만족하는 그룹이 없습니다.
* **힌트:** 그룹화한 후 '합계'와 '개수'를 각각 계산해보세요.

---

**문항 43. [NULL과 집계 함수]**
다음 `MEMBER` 테이블에서 `AVG(POINT)`의 결과값은?

| NAME | POINT |
| --- | --- |
| KIM | 100 |
| LEE | 200 |
| PARK | NULL |

**[SQL]**

```sql
SELECT AVG(POINT) FROM MEMBER;

```

1. 100
2. 150
3. 0
4. NULL

* **정답:** 2)
* **해설:** `AVG` 함수는 NULL을 제외하고 계산합니다. 따라서 이 됩니다. 분모에서도 NULL인 행은 빠집니다.
* **힌트:** 집계 함수에게 NULL은 투명인간입니다.

---

**문항 44. [3개 테이블 조인 결과]**
다음 테이블 관계에서 쿼리 결과로 출력되는 행(Row)의 수는?

* `EMP`: 10명 (부서번호 10번 5명, 20번 5명)
* `DEPT`: 부서번호 10, 20, 30번 (각 1행씩)
* `LOC`: 부서번호 10번은 '서울', 20번은 '부산'

**[SQL]**

```sql
SELECT E.NAME, L.CITY
FROM EMP E, DEPT D, LOC L
WHERE E.DEPTNO = D.DEPTNO
  AND D.DEPTNO = L.DEPTNO;

```

1. 3개
2. 5개
3. 10개
4. 15개

* **정답:** 3)
* **해설:** 10번 부서 5명은 서울로, 20번 부서 5명은 부산으로 매칭됩니다. 총 10명의 사원이 모두 매칭되므로 10행이 출력됩니다.
* **힌트:** 사원 한 명당 최종적으로 어떤 도시가 붙는지 따라가 보세요.

---

**문항 45. [실행 순서와 별칭 오류]**
다음 중 실행 시 오류가 발생하는 쿼리는?

1. `SELECT NAME AS 이름 FROM USER ORDER BY 이름;`
2. `SELECT NAME AS 이름 FROM USER WHERE NAME = 'KIM';`
3. `SELECT NAME AS 이름 FROM USER WHERE 이름 = 'KIM';`
4. `SELECT NAME FROM USER WHERE NAME LIKE 'K%';`

* **정답:** 3)
* **해설:** `WHERE` 절은 `SELECT` 절보다 먼저 실행됩니다. 따라서 `WHERE` 절은 아직 생성되지 않은 별칭인 '이름'을 알 수 없습니다.
* **힌트:** 프-웨-셀-오! (FROM-WHERE-SELECT-ORDER BY)

---

**문항 46. [LEFT JOIN과 NULL]**
다음 두 테이블을 `LEFT OUTER JOIN` 했을 때, 결과에서 `ORDER_ID`가 `NULL`인 사원의 이름은?

* `EMP`: KIM, LEE (2명)
* `ORDERS`: KIM만 1건 주문

**[SQL]**

```sql
SELECT E.NAME, O.ORDER_ID
FROM EMP E LEFT OUTER JOIN ORDERS O
ON E.NAME = O.NAME;

```

1. KIM
2. LEE
3. KIM, LEE
4. 없음

* **정답:** 2)
* **해설:** `LEFT JOIN`은 왼쪽(`EMP`)을 다 보여줍니다. KIM은 주문이 있어 ID가 붙지만, LEE는 주문이 없으므로 ID 자리에 NULL이 채워집니다.
* **힌트:** "주문 안 한 사람 찾기"의 전형적인 문제입니다.

---

**문항 47. [산술 연산과 NULL]**
다음 쿼리의 결과값으로 올바른 것은?

**[SQL]**

```sql
SELECT NVL(100 + NULL, 50) FROM DUAL;

```

1. 150
2. 100
3. 50
4. NULL

* **정답:** 3)
* **해설:** `100 + NULL`의 결과는 `NULL`입니다. `NVL(NULL, 50)`이 되므로 최종 결과는 50입니다.
* **힌트:** 괄호 안의 연산부터 천천히 해결하세요.

---

**문항 48. [DISTINCT의 범위]**
다음 테이블에서 쿼리 실행 시 출력되는 행의 수는?

| DEPT | JOB |
| --- | --- |
| 10 | CLERK |
| 10 | CLERK |
| 10 | MANAGER |
| 20 | CLERK |

**[SQL]**

```sql
SELECT DISTINCT DEPT, JOB FROM TABLE;

```

1. 1개
2. 2개
3. 3개
4. 4개

* **정답:** 3)
* **해설:** `DISTINCT`는 나열된 모든 컬럼의 조합을 하나로 봅니다. (10, CLERK) 조합이 2개이므로 하나로 합쳐져 총 3쌍이 남습니다.
* **힌트:** (부서+직업) 세트가 중복되는지 보세요.

---

**문항 49. [비등가 조인 추론]**
사원 'KIM'의 급여가 2500일 때, 다음 쿼리에서 KIM에게 부여될 `GRADE`는?

[SAL_GRADE 테이블]

* A등급: 1000 ~ 2000
* B등급: 2001 ~ 3000

**[SQL]**

```sql
SELECT S.GRADE
FROM EMP E, SAL_GRADE S
WHERE E.NAME = 'KIM'
  AND E.SAL BETWEEN S.MIN_SAL AND S.MAX_SAL;

```

1. A등급
2. B등급
3. NULL
4. 에러 발생

* **정답:** 2)
* **해설:** 2500은 2001과 3000 사이(BETWEEN)에 해당하므로 B등급과 매칭됩니다.
* **힌트:** 숫자가 어느 범위 바구니에 들어가는지 찾으세요.

---

**문항 50. [문자 함수와 인덱스]**
`SELECT SUBSTR('20260214', 5, 2) FROM DUAL;`의 결과로 올바른 것은?

1. 2026
2. 0214
3. 02
4. 14

* **정답:** 3)
* **해설:** 5번째 글자인 '0'부터 시작하여 2글자를 추출하므로 '02'가 나옵니다.
* **힌트:** 마케팅 데이터에서 '월'만 뽑아낼 때 아주 많이 쓰는 방식입니다.

