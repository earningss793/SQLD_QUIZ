
---

### 📝 [Day19] 트랜잭션, NULL, 식별자

**[1~7번: 트랜잭션 (Transaction)]**

**문항 1.** 다음 중 트랜잭션의 4대 특성(ACID)에 대한 설명으로 올바르지 않은 것은?
**보기:**
① 원자성(Atomicity): 트랜잭션으로 묶인 연산은 모두 성공적으로 실행되거나, 전혀 실행되지 않은 상태로 남아 있어야 한다.
② 일관성(Consistency): 트랜잭션 실행 전 데이터베이스에 이상이 없었다면, 실행 후에도 데이터의 정합성이 일관되게 유지되어야 한다.
③ 고립성(Isolation): 트랜잭션이 실행되는 도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다.
④ 지속성(Durability): 트랜잭션 중 발생한 오류는 시스템 재시작 시 자동으로 이전 상태로 복구되어야 한다.
**정답:** ④
**힌트:** 지속성은 성공적으로 완료된 트랜잭션에 대한 특성입니다.
**해설:** 지속성(Durability)은 성공적으로 수행(Commit)된 트랜잭션의 결과가 시스템 장애가 발생하더라도 데이터베이스에 영구적으로 보존되어야 함을 의미합니다. 자동 복구를 뜻하는 것이 아닙니다.

**문항 2.** 다음 SQL 문장들이 순차적으로 실행되었을 때, 최종적으로 테이블에 남게 되는 데이터로 알맞은 것은? (단, Oracle 기준이며 초기에 테이블은 비어있음)

```sql
INSERT INTO EMP (EMPNO) VALUES (100);
INSERT INTO EMP (EMPNO) VALUES (200);
CREATE TABLE DEPT (DEPTNO NUMBER);
ROLLBACK;

```

**보기:**
① 데이터 없음
② 100
③ 200
④ 100, 200
**정답:** ④
**힌트:** Oracle에서 DDL(CREATE, ALTER, DROP 등)이 실행될 때의 특징을 떠올려보세요.
**해설:** Oracle에서 DDL 문장이 수행되면 그 즉시 이전까지의 DML 작업들이 자동 커밋(Auto Commit)됩니다. `CREATE TABLE DEPT`가 실행되는 순간 `EMPNO` 100과 200의 INSERT 작업이 커밋되었으므로, 이후의 `ROLLBACK`은 아무런 영향을 주지 못합니다.

**문항 3.** 다음 트랜잭션 수행 결과, 최종적으로 테이블(TEST_TB)에 저장되는 값의 합은 얼마인가? (초기 데이터는 없음)

```sql
INSERT INTO TEST_TB (VAL) VALUES (10);
SAVEPOINT SV1;
INSERT INTO TEST_TB (VAL) VALUES (20);
SAVEPOINT SV2;
INSERT INTO TEST_TB (VAL) VALUES (30);
ROLLBACK TO SV1;
INSERT INTO TEST_TB (VAL) VALUES (40);
COMMIT;

```

**보기:**
① 50
② 60
③ 80
④ 100
**정답:** ①
**힌트:** `ROLLBACK TO SV1`이 실행되면 어떤 데이터까지 취소되는지 생각해보세요.
**해설:**

1. 10 입력 (현재: 10)
2. SV1 생성
3. 20 입력 (현재: 10, 20)
4. SV2 생성
5. 30 입력 (현재: 10, 20, 30)
6. `ROLLBACK TO SV1` 수행 -> SV1 이후의 작업(20, 30 입력)이 모두 취소됨 (현재: 10)
7. 40 입력 (현재: 10, 40)
8. COMMIT. 최종 데이터는 10, 40이므로 합은 50입니다.

**문항 4.** 다음 트랜잭션 스크립트를 실행한 후의 결과로 올바른 것은? (초기 데이터 없음)

```sql
INSERT INTO TEST_TB (VAL) VALUES (1);
SAVEPOINT SV1;
INSERT INTO TEST_TB (VAL) VALUES (2);
SAVEPOINT SV1; -- 동일한 이름으로 SAVEPOINT 생성
INSERT INTO TEST_TB (VAL) VALUES (3);
ROLLBACK TO SV1;
COMMIT;

```

**보기:**
① 1만 저장된다.
② 1, 2가 저장된다.
③ 1, 2, 3 모두 저장된다.
④ 아무 데이터도 저장되지 않는다.
**정답:** ②
**힌트:** 동일한 이름의 SAVEPOINT가 생성되면 기존 SAVEPOINT는 어떻게 될까요?
**해설:** 트랜잭션 내에서 동일한 이름의 SAVEPOINT가 생성되면, 기존의 SAVEPOINT는 무효화되고 새로운 위치로 덮어쓰기 됩니다. 따라서 `ROLLBACK TO SV1`은 두 번째 SV1 지점으로 롤백하므로 3을 입력한 작업만 취소되며 1, 2는 저장됩니다.

**문항 5.** 다음 중 테이블의 데이터를 삭제하는 명령어에 대한 설명으로 올바른 것은?
**보기:**
① DELETE 명령어는 DDL이므로 실행 후 ROLLBACK이 불가능하다.
② TRUNCATE 명령어는 데이터를 삭제하면서 테이블의 구조도 완전히 삭제한다.
③ DROP 명령어는 테이블의 구조와 데이터를 모두 삭제하며 ROLLBACK이 불가능하다.
④ DELETE 명령어 수행 시 테이블의 저장 공간(용량)도 즉시 초기화된다.
**정답:** ③
**힌트:** 삭제 명령어 중 DDL과 DML을 구분해 보세요.
**해설:** DROP과 TRUNCATE는 DDL이므로 Auto Commit이 발생하여 롤백이 불가능합니다. 단, TRUNCATE는 데이터와 저장 공간을 비우지만 구조는 남기고, DROP은 객체 자체를 삭제합니다. DELETE는 DML이며 롤백이 가능하고 저장 공간을 즉시 초기화하지 않습니다.

**문항 6.** 다음 중 SQL Server와 Oracle의 트랜잭션 기본 동작 방식에 대한 설명으로 옳은 것은?
**보기:**
① SQL Server는 기본적으로 Auto Commit 방식이므로 DML 수행 후 명시적인 COMMIT이 필요하지 않다.
② Oracle은 기본적으로 Auto Commit 방식이므로 DML 수행 후 명시적인 COMMIT이 필요하지 않다.
③ SQL Server에서 DDL을 수행하면 트랜잭션이 롤백된다.
④ Oracle에서 사용자가 임의로 COMMIT을 수행하면 이후의 트랜잭션은 모두 Auto Commit으로 변경된다.
**정답:** ①
**힌트:** 각 DBMS가 DML을 처리할 때 기본 설정이 어떻게 다른지 떠올려보세요.
**해설:** SQL Server는 기본적으로 DML 수행 시 즉시 반영되는 Auto Commit 방식을 사용합니다. 반면 Oracle은 사용자가 명시적으로 COMMIT이나 ROLLBACK을 수행해야 트랜잭션이 종료됩니다.

**문항 7.** 이미 COMMIT이 완료된 트랜잭션 이후, 이전에 생성해 둔 SAVEPOINT로 `ROLLBACK TO` 명령어를 실행하면 발생하는 결과로 옳은 것은?
**보기:**
① 해당 SAVEPOINT 지점으로 데이터가 정상적으로 롤백된다.
② COMMIT된 내역 중 일부분만 롤백된다.
③ 에러가 발생하며 롤백되지 않는다.
④ 이전 데이터 베이스 상태에 따라 무작위로 복원된다.
**정답:** ③
**힌트:** COMMIT의 수행이 SAVEPOINT에 미치는 영향을 생각해보세요.
**해설:** COMMIT이나 전체 ROLLBACK이 수행되면 트랜잭션이 완전히 종료되므로 이전에 설정해 둔 모든 SAVEPOINT는 즉시 무효화(소멸)됩니다. 따라서 오류가 발생합니다.

---

**[8~14번: NULL의 이해와 함수]**

**문항 8.** 다음 중 NULL에 대한 설명으로 가장 적절하지 않은 것은?
**보기:**
① 숫자 0(Zero)이나 공백(Blank)과는 다른 의미를 갖는다.
② NULL 값에 대한 산술 연산(+, -, *, /)의 결과는 항상 NULL이다.
③ 특정 컬럼이 NULL인지 확인하기 위해서는 `컬럼명 = NULL` 형태의 비교 연산자를 사용해야 한다.
④ 아직 정의되지 않은 미지의 값이나 모르는 값을 의미한다.
**정답:** ③
**힌트:** NULL은 일반적인 비교 연산자로 비교할 수 없습니다.
**해설:** NULL은 `=` 연산자로 비교할 경우 항상 거짓(FALSE / UNKNOWN)을 리턴합니다. 따라서 반드시 `IS NULL` 또는 `IS NOT NULL` 연산자를 사용해야 합니다.

**문항 9.** 다음 표의 데이터를 바탕으로 실행된 두 쿼리의 결과로 알맞은 것은?
| COL1 | COL2 |
| :-- | :-- |
| 10 | NULL |
| 20 | 30 |

* 쿼리 1: `SELECT SUM(COL1) + SUM(COL2) FROM TAB;`
* 쿼리 2: `SELECT SUM(COL1 + COL2) FROM TAB;`
**보기:**
① 쿼리 1: 60, 쿼리 2: 60
② 쿼리 1: NULL, 쿼리 2: NULL
③ 쿼리 1: 60, 쿼리 2: 50
④ 쿼리 1: 60, 쿼리 2: NULL
**정답:** ③
**힌트:** 단일 집계 함수 내부의 NULL 처리와 행 단위 덧셈 연산 시 NULL의 영향을 비교해 보세요.
**해설:** 쿼리 1: SUM(COL1)=30, SUM(COL2)=30 (NULL 무시). 30+30 = 60.
쿼리 2: (10+NULL)=NULL, (20+30)=50. SUM(NULL, 50) = 50. (집계 시 단일 행의 연산 결과가 NULL이 되면 해당 행은 합계에서 누락됨)

**문항 10.** 다음 집계 함수 중 성격이 다른 하나는 무엇인가?
**보기:**
① COUNT(*)
② COUNT(COL_NAME)
③ SUM(COL_NAME)
④ AVG(COL_NAME)
**정답:** ①
**힌트:** 다른 함수들이 특정 컬럼의 NULL 값을 어떻게 취급하는지 생각해보세요.
**해설:** SUM, AVG, MIN, MAX, COUNT(컬럼명) 등 대부분의 집계 함수는 NULL 값을 무시하고 연산을 수행하지만, `COUNT(*)`는 NULL 값을 포함한 테이블의 전체 행 수를 계산합니다.

**문항 11.** 데이터를 정렬(ORDER BY)할 때 DBMS별 NULL 취급 방식에 대한 설명으로 옳은 것은?
**보기:**
① Oracle은 ASC(오름차순) 정렬 시 NULL 값을 맨 처음에 출력한다.
② SQL Server는 DESC(내림차순) 정렬 시 NULL 값을 맨 마지막에 출력한다.
③ Oracle은 NULL을 가장 큰 값으로 간주한다.
④ SQL Server는 NULL을 가장 큰 값으로 간주한다.
**정답:** ③
**힌트:** 오라클은 큰 것을 뒤로 미루고(ASC시 마지막), SQL Server는 반대입니다.
**해설:** Oracle은 NULL을 가장 큰 값으로 간주하여 오름차순(ASC) 시 맨 마지막에 출력합니다. 반면 SQL Server는 NULL을 가장 작은 값으로 취급하여 오름차순 시 맨 처음에 출력합니다. 따라서 ②번의 경우 SQL Server에서 DESC 정렬 시 가장 작은 값이므로 맨 마지막에 출력되는 것이 맞지만 가장 명확한 특징인 ③번이 정답입니다. (수정: SQL Server DESC 시 작은 값인 NULL은 마지막에 오므로 ②도 맞는 설명이 될 수 있어 함정 소지가 있습니다. 명확하게 Oracle=가장 큰 값, SQL Server=가장 작은 값으로 암기해야 합니다. 본 문제의 핵심 정답은 ③)

**문항 12.** 다음 중 여러 인자 중에서 NULL이 아닌 최초의 값을 반환하는 함수는 무엇인가?
**보기:**
① NVL
② NULLIF
③ COALESCE
④ NVL2
**정답:** ③
**힌트:** 매개변수의 개수가 유동적이며 차례대로 평가하는 함수입니다.
**해설:** `COALESCE(인자1, 인자2, ...)` 함수는 입력된 여러 인자 중에서 첫 번째로 NULL이 아닌 값을 반환합니다.

**문항 13.** 다음 SQL 함수의 실행 결과로 알맞은 것은? (단, COMM은 500이다)
`SELECT NULLIF(COMM, 500) FROM EMP;`
**보기:**
① 0
② 500
③ NULL
④ 에러 발생
**정답:** ③
**힌트:** NULLIF는 두 인자가 같을 때 어떤 값을 반환할까요?
**해설:** `NULLIF(인자1, 인자2)`는 인자1과 인자2가 같으면 NULL을 반환하고, 다르면 인자1을 반환합니다. COMM이 500이므로 인자가 같아 NULL을 반환합니다.

**문항 14.** 다음 쿼리의 실행 결과로 옳은 것은? (단, Oracle 데이터베이스 환경이다)
`SELECT 'SQLD' || NULL FROM DUAL;`
**보기:**
① SQLD
② NULL
③ SQLDNULL
④ 에러 발생
**정답:** ①
**힌트:** Oracle에서 문자열 결합 연산자(`||`)와 NULL이 만나면 어떻게 처리되는지 떠올려보세요.
**해설:** Oracle에서 문자열과 NULL을 결합(`||`)하면 NULL을 빈 공백(없는 것)처럼 취급하여 문자열 자체만 출력됩니다. (참고: SQL Server에서는 `+` 연산자로 결합 시 결과 전체가 NULL이 됩니다.)

---

**[15~20번: 식별자 (본질식별자와 인조식별자)]**

**문항 15.** 데이터 모델링에서 식별자에 대한 설명 중 (가)에 들어갈 알맞은 용어는?

> 업무적으로 꼭 필요하지는 않지만, 주식별자가 여러 개의 속성으로 구성되어 복잡하거나 너무 길 때 관리의 편의성을 위해 시스템적으로 인위적으로 부여하는 식별자를 ( 가 )(이)라고 한다.

**보기:**
① 본질 식별자 (Original Identifier)
② 인조 식별자 (Surrogate Identifier)
③ 외부 식별자 (Foreign Identifier)
④ 후보 식별자 (Candidate Identifier)
**정답:** ②
**힌트:** '대리키'라고도 불리며 시스템이 부여하는 번호(예: 일련번호)의 특징입니다.
**해설:** 복잡한 본질식별자를 대체하여 인위적으로 만든 식별자를 인조 식별자(대리 식별자)라고 합니다. 주문번호, 일련번호 등이 대표적인 예입니다.

**문항 16.** 다음 중 인조 식별자를 무분별하게 남용했을 때 발생할 수 있는 문제점(단점)으로 올바르지 않은 것은?
**보기:**
① 본질 식별자가 주는 유일성 제약이 사라져 동일한 데이터가 중복 입력될 수 있다.
② 불필요한 인덱스가 생성되어 저장 공간이 낭비된다.
③ 데이터를 입력, 수정, 삭제하는 DML 작업의 성능이 향상된다.
④ 데이터의 품질이 저하될 우려가 있다.
**정답:** ③
**힌트:** 인덱스가 늘어나면 조회 속도는 오를 수 있지만 갱신 작업(DML)에는 어떤 영향을 줄까요?
**해설:** 인조식별자를 PK로 잡으면 별도의 인덱스가 생성되므로 오히려 데이터를 입력(INSERT), 수정(UPDATE), 삭제(DELETE)하는 DML 성능은 저하됩니다.

**문항 17.** ERD(Entity-Relationship Diagram)에서 부모 엔터티의 주식별자를 자식 엔터티의 주식별자(PK)로 상속받는 관계를 나타내는 선의 형태는 무엇인가?
**보기:**
① 실선 (Solid Line)
② 점선 (Dashed Line)
③ 이중선 (Double Line)
④ 물결선 (Wavy Line)
**정답:** ①
**힌트:** '식별자 관계'를 표현하는 뚜렷한 선을 떠올리세요.
**해설:** 부모의 PK를 자식의 PK로 상속받는 '식별자 관계'는 ERD에서 실선(Solid Line)으로 표현합니다. 자식의 일반 속성(FK)으로만 상속받는 '비식별자 관계'는 점선(Dashed Line)으로 표현합니다.

**문항 18.** 다음 중 본질 식별자(Original Identifier)에 해당하는 예시로 가장 적절한 것은?
**보기:**
① 시스템에서 자동 발급하는 13자리 '주문일련번호'
② 게시판 테이블의 '게시글 번호'
③ 사원 테이블의 '사원번호(사번)'
④ 회원 테이블에 인위적으로 추가한 '회원 가입 순번'
**정답:** ③
**힌트:** 비즈니스 업무상 원래부터 생성되고 의미를 가지는 속성을 찾으세요.
**해설:** 본질 식별자는 업무에 의해 원래부터 만들어지는 식별자입니다. 사원번호, 주민등록번호, 계좌번호 등이 이에 해당합니다. 나머지 예시들은 시스템 편의를 위해 만든 인조 식별자입니다.

**문항 19.** 다음 두 테이블의 관계에 대한 설명으로 옳은 것은?

* 부모: `부서(부서코드(PK), 부서명)`
* 자식: `사원(사원번호(PK), 사원명, 부서코드(FK))`
**보기:**
① 사원 테이블은 부서 테이블과 식별자 관계를 맺고 있다.
② ERD로 표현할 때 두 테이블 사이는 실선으로 연결된다.
③ 사원 테이블은 부서 테이블과 비식별자 관계를 맺고 있다.
④ 부모 테이블의 PK가 자식 테이블의 복합키 중 하나로 사용되었다.
**정답:** ③
**힌트:** 부모의 PK(`부서코드`)가 자식의 어떤 속성으로 들어갔는지 확인하세요.
**해설:** 부모(부서)의 PK인 `부서코드`가 자식(사원)의 주식별자(PK)가 아닌 일반 속성(FK)으로 상속되었습니다. 이를 비식별자 관계라고 하며, ERD에서는 점선으로 표현합니다.

**문항 20.** `GROUP BY` 연산에서 NULL의 처리 방식에 대한 설명으로 올바른 것은?
**보기:**
① `GROUP BY` 대상 컬럼에 NULL 값이 있으면 해당 행은 모두 삭제된다.
② DB는 NULL 값을 가진 행들을 하나로 묶어(모아서) 단일 행으로 그룹화하여 결과를 출력한다.
③ NULL은 값이 없기 때문에 무조건 `GROUP BY` 연산에서 에러를 발생시킨다.
④ `GROUP BY` 연산 시 NULL 값들은 각각 개별적인 독립 그룹으로 나뉘어 출력된다.
**정답:** ②
**힌트:** NULL 값들의 집합을 DB가 어떻게 묶어주는지 교안 2.3 파트를 떠올려보세요.
**해설:** `GROUP BY` 절에 명시된 컬럼에 NULL 값이 여러 개 존재할 경우, 데이터베이스는 NULL 값들을 하나의 범주로 취급하여 단일 그룹으로 묶어 처리합니다. 결과에는 NULL 그룹이 하나의 행으로 출력됩니다.