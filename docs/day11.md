강의 내용을 완벽하게 소화했는지 확인하기 위한 **'고급 SQL 정복 20제'**입니다. 5문제씩 끊어서 난이도가 올라가니, 긴장 풀지 말고 도전해 보세요!

---

## [Level 1] 기초 다지기: "개념이 잡혀 있는가?"

**1. Oracle에서 급여(SAL)가 높은 상위 5명을 뽑기 위해 `ROWNUM`을 사용할 때, 올바른 쿼리 구조는?**

* ① `SELECT * FROM EMP WHERE ROWNUM <= 5 ORDER BY SAL DESC;`
* ② `SELECT * FROM EMP ORDER BY SAL DESC WHERE ROWNUM <= 5;`
* ③ `SELECT * FROM (SELECT * FROM EMP ORDER BY SAL DESC) WHERE ROWNUM <= 5;`
* ④ `SELECT * FROM EMP WHERE ROWNUM < 6;`
* **정답:** ③
* **해설:** Oracle의 `ROWNUM`은 `ORDER BY`보다 먼저 실행되므로, 서브쿼리(인라인 뷰)로 정렬을 먼저 수행한 뒤 추출해야 합니다.
* **힌트:** 번호표는 줄을 다 선 다음에 나눠줘야 공평하겠죠?

**2. SQL Server에서 `TOP (5) WITH TIES`를 사용했을 때 나타날 수 있는 현상은?**

* ① 무조건 5개의 행만 출력된다.
* ② 급여가 동일한 공동 5등이 있다면 5행을 초과하여 출력될 수 있다.
* ③ 5등까지만 출력하고 나머지 동점자는 버린다.
* ④ 상위 5%의 데이터를 출력한다.
* **정답:** ②
* **해설:** `WITH TIES` 옵션은 마지막 순위와 동일한 값을 가진 행들을 모두 포함시켜 출력합니다.
* **힌트:** '의리 있는 5등'을 떠올려 보세요.

**3. 셀프 조인(Self Join)을 수행할 때 반드시 지켜야 하는 규칙은?**

* ① 반드시 `LEFT OUTER JOIN`을 사용해야 한다.
* ② 두 테이블의 컬럼명이 완전히 달라야 한다.
* ③ 동일 테이블을 사용하므로 테이블 별칭(Alias)을 다르게 지정해야 한다.
* ④ `WHERE` 절에 반드시 `ROWNUM` 조건을 넣어야 한다.
* **정답:** ③
* **해설:** 컴퓨터가 같은 테이블을 서로 다른 개체로 인식하게 하려면 별칭(E, M 등)이 필수입니다.
* **힌트:** 도플갱어에게 서로 다른 이름표를 붙여준다고 생각하세요.

**4. 계층형 질의에서 최상위 노드(Root)부터 전개를 시작하도록 지정하는 구문은?**

* ① `CONNECT BY`
* ② `ORDER SIBLINGS BY`
* ③ `START WITH`
* ④ `PRIOR`
* **정답:** ③
* **해설:** `START WITH`는 계층 구조의 시작점(뿌리)을 지정하는 조건절입니다.
* **힌트:** "누구부터 시작할까?"라는 질문에 대한 답입니다.

**5. 계층형 질의의 가상 컬럼 중, 현재 노드의 깊이(Root=1, 자식=2...)를 나타내는 것은?**

* ① `LEVEL`
* ② `CONNECT_BY_ISLEAF`
* ③ `ROWNUM`
* ④ `DEPTH`
* **정답:** ①
* **해설:** `LEVEL`은 트리 구조에서 해당 데이터가 몇 번째 층에 있는지를 숫자로 반환합니다.
* **힌트:** 아파트 층수를 세는 것과 비슷합니다.

---

## [Level 2] 응용하기: "함수를 구분할 수 있는가?"

**6. 다음 데이터를 기준으로 `RANK()` 함수를 사용하여 급여 순위를 매겼을 때, 결과값이 순서대로 옳은 것은?**

> **[데이터]** 김철수(500), 이영희(400), 박민수(400), 최정윤(300)

* ① 1, 2, 3, 4
* ② 1, 2, 2, 3
* ③ 1, 2, 2, 4
* ④ 1, 1, 2, 3
* **정답:** ③
* **해설:** `RANK()`는 공동 순위만큼 숫자를 건너뜁니다. 2등이 2명이므로 3등을 건너뛰고 4등이 나옵니다.
* **힌트:** 올림픽이나 수능 등수 계산법을 생각해보세요.

**7. 셀프 조인을 활용해 '나의 상사 이름'을 조회하려고 합니다. 빈칸에 알맞은 조인 조건은?**

```sql
SELECT E.ENAME AS 사원, M.ENAME AS 상사
FROM EMP E JOIN EMP M ON (  빈칸  );

```

* ① `E.EMPNO = M.EMPNO`
* ② `E.MGR = M.MGR`
* ③ `E.MGR = M.EMPNO`
* ④ `E.EMPNO = M.MGR`
* **정답:** ③
* **해설:** 내 줄에 적힌 관리자 번호(`E.MGR`)와 일치하는 사번(`M.EMPNO`)을 가진 사람을 관리자 테이블(`M`)에서 찾아야 합니다.
* **힌트:** 내 수첩에 적힌 '상사 사번'을 들고 사번 명부를 뒤지러 가야죠.

**8. 계층형 질의에서 `CONNECT BY PRIOR 사번 = 관리자사번`의 전개 방향은?**

* ① 역방향 (부하 -> 상사)
* ② 순방향 (상사 -> 부하)
* ③ 수평방향 (동료 -> 동료)
* ④ 무작위방향
* **정답:** ②
* **해설:** `PRIOR`가 부모 쪽에 붙어 있으면 부모에서 자식으로 내려가는 순방향 전개입니다.
* **힌트:** `PRIOR` 뒤에 오는 '사번'이 먼저 읽힌 데이터(상사)입니다.

**9. `SYS_CONNECT_BY_PATH(ENAME, '/')` 함수의 결과 예시로 적절한 것은?**

* ① `1/2/3/4`
* ② `사장/부장/대리`
* ③ `/김사장/이부장/최대리`
* ④ `최대리 > 이부장 > 김사장`
* **정답:** ③
* **해설:** 루트 노드부터 현재 노드까지의 경로를 지정한 구분자와 함께 문자열로 연결해줍니다.
* **힌트:** 윈도우 탐색기 주소창의 폴더 경로와 비슷합니다.

**10. 다음 중 최신 표준 문법인 `OFFSET FETCH`를 사용하여 6등부터 10등까지의 데이터를 출력하는 구문은?**

* ① `FETCH NEXT 5 ROWS ONLY`
* ② `OFFSET 6 ROWS FETCH NEXT 5 ROWS ONLY`
* ③ `OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY`
* ④ `OFFSET 5 ROWS FETCH NEXT 10 ROWS ONLY`
* **정답:** ③
* **해설:** 6등부터 보려면 앞의 5명(`OFFSET 5`)을 건너뛰고, 그 후 5개(`FETCH NEXT 5`)를 가져와야 합니다.
* **힌트:** 건너뛸 개수를 먼저 정하세요.

---

## [Level 3] 함정 탈출: "함정에 빠지지 않는가?"

**11. 다음 SQL의 실행 결과로 올바른 것은?**

```sql
SELECT ENAME FROM EMP WHERE ROWNUM = 2;

```

* ① 2번째 행의 사원명이 출력된다.
* ② 에러가 발생한다.
* ③ 아무 결과도 출력되지 않는다 (0건).
* ④ 전체 사원이 출력된다.
* **정답:** ③
* **해설:** `ROWNUM`은 1번이 확정되어야 2번이 생성됩니다. 조건에서 1번을 배제했으므로 2번은 영원히 나타나지 않습니다.
* **힌트:** 1등 없는 2등은 존재할 수 없습니다.

**12. 아래 테이블 구조에서 '사원'에서 '사장'으로 올라가는 역방향 조회를 하려고 합니다. 올바른 `CONNECT BY` 조건은?**
| 사번(EMPNO) | 관리자(MGR) |
| :--- | :--- |
| 100(사장) | NULL |
| 200(부장) | 100 |

* ① `CONNECT BY PRIOR EMPNO = MGR`
* ② `CONNECT BY PRIOR MGR = EMPNO`
* ③ `CONNECT BY MGR = EMPNO`
* ④ `CONNECT BY EMPNO = MGR`
* **정답:** ②
* **해설:** 현재 데이터(부하)의 관리자 번호(`MGR`)를 이전 데이터(`PRIOR`)의 사번으로 찾아 올라가야 합니다.
* **힌트:** `PRIOR`는 '방금 읽은 사람'입니다.

**13. 계층형 질의에서 형제 노드들끼리의 순서를 이름순으로 정렬하면서도 트리 구조를 깨뜨리지 않는 방법은?**

* ① `ORDER BY ENAME`
* ② `GROUP BY ENAME`
* ③ `ORDER SIBLINGS BY ENAME`
* ④ `SORT BY ENAME`
* **정답:** ③
* **해설:** 일반 `ORDER BY`를 쓰면 계층이 무시되고 전체가 섞여버립니다. 계층 내 정렬은 `SIBLINGS`가 필수입니다.
* **힌트:** '형제(Siblings)'라는 단어를 기억하세요.

**14. 셀프 조인을 수행한 결과, 상사가 없는 '사장' 데이터가 결과에서 누락되었습니다. 이를 방지하기 위한 조인 방법은?**

* ① `INNER JOIN`
* ② `FULL OUTER JOIN`
* ③ `LEFT OUTER JOIN`
* ④ `CROSS JOIN`
* **정답:** ③
* **해설:** 사원(`E`) 테이블에는 있지만 상사(`M`) 테이블에는 대응하는 데이터가 없는 경우(MGR IS NULL)에도 출력하려면 왼쪽 외부 조인이 필요합니다.
* **힌트:** 상사가 없어도 '사원'으로서의 정보는 나와야 합니다.

**15. `WHERE CONNECT_BY_ISLEAF = 1` 조건을 추가했을 때의 결과는?**

* ① 사장님만 출력된다.
* ② 부장님들만 출력된다.
* ③ 부하 직원이 없는 최하위 팀원들만 출력된다.
* ④ 모든 데이터가 출력된다.
* **정답:** ③
* **해설:** `ISLEAF`는 자식이 없는 말단 노드일 때 1을 반환합니다.
* **힌트:** 나뭇잎(Leaf)은 나무의 가장 끝부분에 달려 있죠.

---

## [Level 4] 최고난도: "데이터를 추론할 수 있는가?"

**16. 다음 쿼리의 실행 결과로 알맞은 순서는? (데이터는 3.1절 조직도 참조)**

```sql
SELECT ENAME FROM EMP
START WITH ENAME = '이부장'
CONNECT BY PRIOR EMPNO = MGR
ORDER SIBLINGS BY ENAME;

```

* ① 이부장 - 박부장 - 최대리 - 정사원
* ② 이부장 - 최대리 - 정사원
* ③ 김사장 - 이부장 - 최대리 - 정사원
* ④ 이부장 - 최대리
* **정답:** ②
* **해설:** 시작점이 '이부장'이므로 김사장과 박부장은 제외됩니다. 이부장 아래의 계층인 최대리, 정사원만 출력됩니다.
* **힌트:** `START WITH`가 필터링 역할을 한다는 점에 주의하세요.

**17. 아래 쿼리의 결과에서 `RK`가 3인 사람은 몇 명인가?**

> **[SAL 데이터]** A(100), B(100), C(90), D(80), E(80)

```sql
SELECT ENAME, DENSE_RANK() OVER (ORDER BY SAL DESC) AS RK FROM EMP;

```

* ① 0명
* ② 1명
* ③ 2명
* ④ 3명
* **정답:** ③
* **해설:** 100(A, B)은 공동 1등, 그다음 점수인 90(C)은 2등, 그다음 점수인 80(D, E)은 3등이 됩니다. `DENSE_RANK`는 순위를 건너뛰지 않습니다.
* **힌트:** `DENSE`는 '빽빽하게' 순위를 채웁니다.

**18. 계층형 질의에서 `PRIOR` 키워드를 다음과 같이 사용했을 때 발생하는 현상은?**
`SELECT ... FROM EMP START WITH ENAME = '정사원' CONNECT BY EMPNO = PRIOR MGR;`

* ① 정사원부터 시작하여 사장까지 거슬러 올라간다.
* ② 정사원부터 시작하여 그 아래 부하들을 조회한다.
* ③ 에러가 발생한다.
* ④ 정사원 한 명만 출력되고 종료된다.
* **정답:** ①
* **해설:** `PRIOR`가 부모(MGR) 쪽에 붙어 있으므로, 방금 읽은 사람의 상사를 찾아가는 역방향 전개입니다.
* **힌트:** 내 관리자 번호를 사번으로 가진 사람을 '직전 데이터'로 삼겠다는 뜻입니다.

**19. 다음 SQL 결과로 출력되는 행의 수는?**
| 사번 | 이름 | 급여 |
| :--- | :--- | :--- |
| 1 | 김 | 500 |
| 2 | 이 | 500 |
| 3 | 박 | 400 |
| 4 | 최 | 300 |

```sql
SELECT TOP (2) WITH TIES 이름 FROM EMP ORDER BY 급여 DESC;

```

* ① 1개
* ② 2개
* ③ 3개
* ④ 4개
* **정답:** ②
* **해설:** 급여가 500인 김과 이가 공동 1등입니다. 2개를 뽑으라고 했으므로 1등 두 명이 출력되고 끝납니다. (만약 박도 500이었다면 3개가 나왔을 것입니다.)
* **힌트:** '마지막 순위'의 동점자가 있는지를 확인하세요.

**20. 계층형 쿼리와 셀프 조인에 대한 설명 중 틀린 것은?**

* ① 계층형 쿼리는 한 번의 작성으로 무제한 깊이의 트리를 탐색할 수 있다.
* ② 셀프 조인은 계층의 깊이가 깊어질수록 `JOIN` 문을 계속 추가해야 하므로 불리하다.
* ③ `CONNECT BY` 절에서 `PRIOR`는 반드시 컬럼명 왼쪽에만 올 수 있다.
* ④ 셀프 조인은 서로 다른 별칭을 사용해 논리적으로 두 개의 테이블로 분리한다.
* **정답:** ③
* **해설:** `PRIOR`는 `=` 연산자의 어느 쪽에 와도 상관없습니다. 어느 컬럼에 붙느냐가 중요할 뿐입니다. (예: `MGR = PRIOR EMPNO` 가능)
* **힌트:** 문법적 위치보다는 '누구의 데이터인가'라는 논리가 중요합니다.

---

**고생하셨습니다!** 이 20문제를 모두 이해했다면 당신은 이미 SQL 고급 조회 기술의 마스터입니다. 혹시 특정 문제의 해설이 더 필요하신가요? 끝까지 도와드릴게요!