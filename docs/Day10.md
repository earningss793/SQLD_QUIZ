**DAY 10: 윈도우 함수(Window Function)** 

---

## 🟢 1단계: 기초 - "윈도우 함수와 친해지기"

**[Q1] 다음 중 윈도우 함수와 GROUP BY 절의 차이점에 대한 설명으로 가장 적절한 것은?**

* ① 윈도우 함수는 행의 수를 줄이지만, GROUP BY는 행의 수를 유지한다.
* ② 윈도우 함수는 행의 수를 유지하지만, GROUP BY는 행의 수를 줄인다.
* ③ 두 기능 모두 행의 수를 줄여서 집계 결과를 보여준다.
* ④ 윈도우 함수는 SELECT 절에서 사용할 수 없다.

> **정답:** ②
> **해설:** GROUP BY는 데이터를 그룹별로 압축(집계)하여 행 수가 줄어들지만, 윈도우 함수는 개별 행의 상세 정보를 유지하면서 분석 결과를 옆에 추가합니다.
> **힌트:** 내 성적표 옆에 '반 평균'이 찍히는지, 아니면 '반 평균'만 덜렁 나오는지 생각해보세요.

**[Q2] 윈도우 함수 사용 시 반드시 함께 작성해야 하는 필수 키워드는?**

* ① WHERE
* ② GROUP BY
* ③ OVER
* ④ HAVING

> **정답:** ③
> **해설:** 윈도우 함수는 항상 `함수() OVER ( ... )` 형식을 갖춰야 합니다.
> **힌트:** 창문(Window)을 넘어서(OVER) 본다고 외우세요!

**[Q3] 다음 중 동점자가 있을 때 동일 순위를 부여하고, 그 다음 순위는 건너뛰는(예: 1등, 1등, 3등) 함수는?**

* ① RANK
* ② DENSE_RANK
* ③ ROW_NUMBER
* ④ NTILE

> **정답:** ①
> **해설:** `RANK`는 올림픽 방식처럼 공동 순위만큼 다음 숫자를 건너뜁니다.
> **힌트:** 1등이 두 명이면 2등 없이 바로 3등으로 가는 냉정한 함수입니다.

**[Q4] 값이 동일하더라도 무조건 고유한 일련번호를 부여하는(예: 1, 2, 3, 4) 순위 함수는?**

* ① RANK
* ② DENSE_RANK
* ③ ROW_NUMBER
* ④ CUME_DIST

> **정답:** ③
> **해설:** `ROW_NUMBER`는 동일한 값에 대해서도 순차적인 고유 번호를 부여합니다.
> **힌트:** 출석 번호처럼 무조건 겹치지 않게 매기는 번호입니다.

**[Q5] 윈도우 함수 내부에서 '전체를 어떤 기준으로 나눌 것인가'를 지정하는 구문은?**

* ① ORDER BY
* ② PARTITION BY
* ③ GROUP BY
* ④ ROWS BETWEEN

> **정답:** ②
> **해설:** `PARTITION BY`는 전체 집합을 특정 기준(예: 부서, 성별)으로 나누는 역할을 합니다.
> **힌트:** "부서별"로 등수를 매기고 싶다면 `PARTITION BY 부서`입니다.

---

## 🟡 2단계: 중급 - "순위와 리셋의 원리"

**[Q6] 다음 데이터를 보고 `DENSE_RANK() OVER (ORDER BY 점수 DESC)`를 적용했을 때, 90점인 학생의 순위는?**
(데이터: 100점, 100점, 90점, 80점)

* ① 1
* ② 2
* ③ 3
* ④ 4

> **정답:** ②
> **해설:** `DENSE_RANK`는 공동 순위가 있어도 다음 숫자를 이어서 매깁니다. (1, 1, 2, 3)
> **힌트:** 빽빽하다는 뜻의 'Dense'답게 순위 사이에 빈틈이 없습니다.

**[Q7] `PARTITION BY DEPTNO`를 사용하여 순위를 매길 때 발생하는 현상으로 옳은 것은?**

* ① 부서 번호가 바뀌어도 순위는 계속 누적된다.
* ② 부서 번호가 바뀔 때마다 순위가 1등부터 다시 시작된다.
* ③ 부서별로 한 명의 사원만 조회된다.
* ④ 전체 사원의 평균 급여가 출력된다.

> **정답:** ②
> **해설:** `PARTITION BY`로 나뉜 그룹이 변경되면 윈도우 함수의 계산은 다시 초기화(Reset)됩니다.
> **힌트:** 각 부서마다 '과탑'을 따로 뽑는다고 생각하세요.

**[Q8] 10명의 사원을 `NTILE(3)`으로 나누었을 때, 각 조의 인원 배분으로 옳은 것은?**

* ① 4명, 3명, 3명
* ② 3명, 3명, 4명
* ③ 3명, 3명, 3명, 1명
* ④ 5명, 5명, 0명

> **정답:** ①
> **해설:** `NTILE(N)`은 최대한 균등하게 나누되, 나머지가 생기면 앞의 조부터 한 명씩 더 배정합니다.
> **힌트:** 앞에서부터 한 명씩 더 챙겨주는 조 편성입니다.

**[Q9] 다음 중 윈도우 함수를 사용할 수 있는 위치로 옳은 것은?**

* ① SELECT 절
* ② WHERE 절
* ③ GROUP BY 절
* ④ HAVING 절

> **정답:** ①
> **해설:** 윈도우 함수는 결과 집합이 결정된 후 적용되므로 SELECT 절에서만 사용할 수 있습니다. (정렬을 위해 ORDER BY 절에도 사용 가능)
> **힌트:** 필터링(WHERE)은 윈도우 함수보다 먼저 일어납니다.

**[Q10] OVER 절 안에 `ORDER BY`가 없을 때 `SUM(SAL) OVER()`의 결과는?**

* ① 급여순으로 누적된 합계
* ② 해당 그룹(또는 전체)의 총 합계
* ③ 모든 행에 0이 출력됨
* ④ 오류 발생

> **정답:** ②
> **해설:** 순서(`ORDER BY`)가 없으면 누적 계산을 할 수 없으므로 전체 합계를 모든 행에 동일하게 보여줍니다.
> **힌트:** 누적하려면 줄을 세워야 합니다. 줄이 없으면 그냥 통째로 더합니다.

---

## 🟠 3단계: 상급 - "범위 지정과 행 이동"

**[Q11] 바로 이전 행의 특정 컬럼 값을 가져오는 함수는?**

* ① LEAD
* ② LAG
* ③ FIRST_VALUE
* ④ LAST_VALUE

> **정답:** ②
> **해설:** `LAG`는 현재 행을 기준으로 이전 행의 데이터를 가져옵니다.
> **힌트:** 게임에서 렉(Lag) 걸리면 뒤처지는 것을 떠올리세요.

**[Q12] 다음 SQL의 결과로 가장 적절한 것은?**

```sql
SELECT 월, 매출, LAG(매출, 1, 0) OVER (ORDER BY 월) AS 전월매출
FROM 월별매출표;

```

* ① 1월의 '전월매출'은 NULL로 나온다.
* ② 1월의 '전월매출'은 0으로 나온다.
* ③ 이전 달 매출이 없으면 오류가 발생한다.
* ④ 12월의 다음 달 매출을 가져온다.

> **정답:** ②
> **해설:** `LAG`의 세 번째 인자는 값이 없을 때(NULL일 때) 보여줄 기본값을 지정합니다.
> **힌트:** NULL 대신 0을 넣어서 계산하기 편하게 만든 쿼리입니다.

**[Q13] `ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING`의 의미는?**

* ① 맨 처음부터 현재 행까지
* ② 현재 행부터 맨 마지막까지
* ③ 바로 앞 행, 현재 행, 바로 다음 행 (총 3줄)
* ④ 전체 행

> **정답:** ③
> **해설:** 현재 행을 기준으로 앞(PRECEDING) 1줄과 뒤(FOLLOWING) 1줄을 포함한 범위를 의미합니다.
> **힌트:** 나를 중심으로 앞뒤 동료 한 명씩만 챙기는 범위입니다.

**[Q14] 다음 중 누적 분포를 구하는 함수로, 나보다 순위가 높거나 같은 사람의 비율을 0~1 사이로 반환하는 함수는?**

* ① PERCENT_RANK
* ② CUME_DIST
* ③ RATIO_TO_REPORT
* ④ NTILE

> **정답:** ②
> **해설:** `CUME_DIST`는 누적 분포를 계산하며, (나보다 작거나 같은 값의 수 / 전체 건수)를 반환합니다.
> **힌트:** 4명 중 1등이면 1/4 = 0.25가 나옵니다.

**[Q15] 윈도우 함수에서 `UNBOUNDED PRECEDING`의 의미는?**

* ① 현재 행의 값
* ② 파티션의 맨 마지막 행
* ③ 파티션의 맨 첫 번째 행 (끝없는 이전)
* ④ 값이 NULL인 행

> **정답:** ③
> **해설:** 윈도우 범위의 시작점을 파티션의 첫 번째 행으로 고정할 때 사용합니다.
> **힌트:** 누적 합계를 구할 때 '맨 처음부터'를 의미하는 필수 키워드입니다.

---

## 🔴 4단계: 심화 - "킬러 문항 정복"

**[Q16] 다음 중 `ROWS`와 `RANGE`의 차이점에 대한 설명으로 옳은 것은?**

* ① `ROWS`는 값의 크기를 기준으로, `RANGE`는 행의 개수를 기준으로 계산한다.
* ② `ROWS`는 물리적인 행의 위치를, `RANGE`는 논리적인 값의 크기를 기준으로 한다.
* ③ 두 키워드 모두 결과가 항상 동일하다.
* ④ `RANGE`는 동점자가 있어도 무조건 한 행씩 누적한다.

> **정답:** ②
> **해설:** `ROWS`는 행 번호로 범위를 잡고, `RANGE`는 컬럼의 값을 기준으로 범위를 잡습니다.
> **힌트:** 값이 같은 데이터가 여러 개 있을 때 `RANGE`는 한꺼번에 묶어서 처리합니다.

**[Q17] 아래 데이터를 보고 `SUM(금액) OVER (ORDER BY 금액 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)`를 실행했을 때, 두 번째 100원 행의 결과값은?**
(데이터: 100원(A), 100원(B), 300원(C))

* ① 100
* ② 200
* ③ 500
* ④ 0

> **정답:** ②
> **해설:** `RANGE`는 값이 같은(100원) 행들을 하나의 논리적 그룹으로 보기 때문에 A, B행 모두 합산된 200을 출력합니다.
> **힌트:** 값이 같으면 '동지'로 보고 한방에 계산하는 것이 `RANGE`의 특징입니다.

**[Q18] `LAST_VALUE` 함수를 사용할 때 `ORDER BY`만 적고 범위를 지정하지 않으면 현재 행의 값이 나오는 이유는 무엇인가?**

* ① 함수가 고장 났기 때문이다.
* ② 윈도우 함수의 기본 범위(Default)가 `UNBOUNDED PRECEDING AND CURRENT ROW`이기 때문이다.
* ③ `LAST_VALUE`는 원래 현재 행까지만 읽는다.
* ④ `ORDER BY`를 쓰면 자동으로 `ROWS` 모드가 되기 때문이다.

> **정답:** ②
> **해설:** 기본 범위가 '처음부터 현재 행'까지이므로, 현재 행이 그 윈도우 안에서는 항상 '마지막'이 됩니다.
> **힌트:** 진짜 마지막을 보려면 창문을 `UNBOUNDED FOLLOWING`(끝까지) 열어줘야 합니다.

**[Q19] 전체 합계 대비 현재 행의 값이 차지하는 비율을 구하는 함수는?**

* ① RATIO_TO_REPORT
* ② PERCENT_RANK
* ③ CUME_DIST
* ④ ROW_NUMBER

> **정답:** ①
> **해설:** `RATIO_TO_REPORT`는 파티션 내 전체 합계에 대한 개별 행의 비중을 계산합니다.
> **힌트:** "내 월급 / 우리 부서 전체 월급 합계"를 구할 때 딱입니다.

**[Q20] SQL의 논리적 실행 순서상 윈도우 함수가 실행되는 시점은?**

* ① WHERE 절 실행 직후
* ② SELECT 절에서 컬럼이 선택될 때
* ③ ORDER BY 절 실행 직후
* ④ FROM 절에서 데이터를 읽을 때

> **정답:** ②
> **해설:** 윈도우 함수는 `WHERE`, `GROUP BY`, `HAVING` 절까지 모두 완료된 후 `SELECT` 단계에서 계산됩니다.
> **힌트:** 모든 필터링과 그룹화가 끝난 '최종 명단' 위에서 계산이 시작됩니다.

--