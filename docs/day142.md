
## 📝 SQLD 합격 대비 실전 모의고사 (50문항)

### [PART 1] SQL 기본 (DAY 1 ~ 5)

**1. 다음 중 NULL에 대한 산술 연산 결과로 옳은 것은?**

* ① NULL + 100 = 100
* ② NULL * 0 = 0
* ③ NULL / 5 = NULL
* ④ NULL - NULL = 0

> **정답**: ③
> **해설**: NULL은 '알 수 없는 값'이므로 어떤 숫자와 연산해도 결과는 항상 NULL입니다.
> **힌트**: NULL과 놀면 결과는 항상 NULL이 된다는 점을 기억하세요.

**2. 다음 SQL 문장의 실행 순서로 올바른 것은?**

```sql
SELECT ENAME, SAL FROM EMP WHERE SAL > 2000 ORDER BY ENAME;

```

* ① SELECT -> FROM -> WHERE -> ORDER BY
* ② FROM -> WHERE -> SELECT -> ORDER BY
* ③ FROM -> SELECT -> WHERE -> ORDER BY
* ④ WHERE -> FROM -> SELECT -> ORDER BY

> **정답**: ②
> **해설**: SQL의 논리적 실행 순서는 FROM(재료) -> WHERE(필터) -> SELECT(추출) -> ORDER BY(정렬) 순입니다.
> **힌트**: 프-웨-그-하-셀-오(FWGHSO)를 암기하세요.

**3. 다음 중 에러가 발생하는 SQL 문장은?**

* ① `SELECT ENAME AS 이름 FROM EMP WHERE SAL > 2000;`
* ② `SELECT ENAME 이름 FROM EMP ORDER BY 이름;`
* ③ `SELECT ENAME AS 이름 FROM EMP WHERE 이름 = 'SMITH';`
* ④ `SELECT * FROM EMP;`

> **정답**: ③
> **해설**: WHERE 절은 SELECT 절보다 먼저 실행되므로 SELECT 절에서 정의한 별칭(Alias)을 WHERE 절에서 사용할 수 없습니다.
> **힌트**: 실행 순서상 WHERE 단계에서는 아직 '이름'이라는 별명이 태어나지 않았습니다.

**4. 다음 중 중복된 데이터를 제거하고 종류별로 하나씩만 출력하는 키워드는?**

* ① ALL
* ② DISTINCT
* ③ UNIQUE
* ④ GROUP BY

> **정답**: ②
> **해설**: SELECT 바로 뒤에 DISTINCT를 붙이면 중복 행을 제거한 결과가 출력됩니다.
> **힌트**: 1일차 강의안의 '중복 제거' 파트를 참고하세요.

**5. 다음 중 문자열 함수에 대한 설명으로 부적절한 것은?**

* ① `LOWER`는 문자열을 소문자로 변환한다.
* ② `SUBSTR('ABCDE', 2, 2)`의 결과는 'BC'이다.
* ③ `LTRIM`은 문자열 오른쪽의 공백을 제거한다.
* ④ `CONCAT`은 두 문자열을 하나로 합친다.

> **정답**: ③
> **해설**: LTRIM은 왼쪽(Left) 공백을 제거하며, 오른쪽 공백 제거는 RTRIM입니다.
> **힌트**: L은 Left, R은 Right입니다.

**6. 오라클 환경에서 `ROUND(123.456, 1)`의 실행 결과는?**

* ① 123
* ② 123.4
* ③ 123.5
* ④ 120

> **정답**: ③
> **해설**: 소수점 첫째 자리까지 표시하기 위해 둘째 자리에서 반올림합니다.
> **힌트**: 양수 인덱스는 소수점 자릿수를 의미합니다.

**7. 다음 중 날짜 함수에 대한 설명으로 옳은 것은?**

* ① `SYSDATE`는 SQL Server의 현재 시간을 가져온다.
* ② `날짜 + 1`은 해당 날짜에 1시간을 더한 결과다.
* ③ `EXTRACT(YEAR FROM SYSDATE)`는 현재 년도를 숫자로 반환한다.
* ④ 날짜와 날짜를 더하면 두 날짜 사이의 일수가 계산된다.

> **정답**: ③
> **해설**: EXTRACT는 특정 날짜 요소를 추출합니다. 2번은 1일(24시간)을 더하는 것이며, 4번은 날짜 간의 뺄셈이 일수 계산입니다.
> **힌트**: 날짜 연산의 기본 단위는 '일(Day)'입니다.

**8. 보너스(COMM) 컬럼이 NULL인 경우 0으로 치환하여 급여(SAL)와 더하는 함수로 적절한 것은? (Oracle 기준)**

* ① `ISNULL(COMM, 0)`
* ② `NVL(COMM, 0)`
* ③ `NULLIF(COMM, 0)`
* ④ `COALESCE(COMM, 0)`

> **정답**: ②
> **해설**: NVL(값, 대체값)은 값이 NULL인 경우 대체값을 반환합니다. 1번은 SQL Server 함수입니다.
> **힌트**: 3일차 NULL 처리 함수 표를 확인하세요.

**9. 다음 중 집계 함수와 NULL의 관계에 대한 설명으로 틀린 것은?**

* ① `COUNT(*)`는 NULL을 포함하여 행의 수를 샌다.
* ② `SUM(SAL)`은 SAL이 NULL인 행을 제외하고 합계를 구한다.
* ③ `AVG(SAL)`은 전체 행 수로 합계를 나누어 평균을 구한다.
* ④ `MAX`와 `MIN`은 NULL을 무시하고 계산한다.

> **정답**: ③
> **해설**: AVG는 NULL인 행을 '분모'에서도 제외하고 평균을 구합니다. (합계 / NULL이 아닌 행의 수)
> **힌트**: 집계 함수는 기본적으로 NULL을 '무시'합니다.

**10. 아래 SQL 문장의 에러 원인으로 가장 적절한 것은?**

```sql
SELECT DEPTNO, ENAME, SUM(SAL)
FROM EMP
GROUP BY DEPTNO;

```

* ① SUM 함수는 GROUP BY와 함께 쓸 수 없다.
* ② ENAME 컬럼이 GROUP BY 절에 명시되지 않았다.
* ③ DEPTNO는 숫자형이라 그룹화할 수 없다.
* ④ FROM 절에 테이블 별칭이 없다.

> **정답**: ②
> **해설**: GROUP BY 사용 시 SELECT 절에 있는 집계되지 않은 일반 컬럼은 반드시 GROUP BY에 포함되어야 합니다.
> **힌트**: 4일차 "팀별 회식비 정산" 비유를 떠올려보세요.

**11. 다음 중 HAVING 절에 대한 설명으로 옳은 것은?**

* ① WHERE 절과 동일한 기능을 수행한다.
* ② 집계 함수를 이용한 조건 필터링이 가능하다.
* ③ GROUP BY 절 없이도 단독으로 사용 가능하다.
* ④ 실행 순서상 WHERE 절보다 먼저 실행된다.

> **정답**: ②
> **해설**: HAVING은 그룹화된 결과(집계 결과)에 조건을 걸 때 사용합니다.
> **힌트**: 4일차 사과 선별 작업 비유에서 '박스 무게 재기' 단계입니다.

**12. 다음 중 INNER JOIN에 대한 설명으로 가장 부적절한 것은?**

* ① 조인 조건에 맞는 데이터가 양쪽 테이블에 모두 있을 때만 출력된다.
* ② 교집합과 유사한 성격을 갖는다.
* ③ Oracle에서는 WHERE 절에 조인 조건을 기술할 수 있다.
* ④ 한쪽 테이블에만 데이터가 있어도 무조건 출력된다.

> **정답**: ④
> **해설**: 양쪽 모두 존재해야 하는 것이 INNER JOIN이며, 한쪽만 있어도 출력되는 것은 OUTER JOIN입니다.
> **힌트**: 소개팅에서 매칭된 커플만 보여주는 방식입니다.

**13. 다음 중 NATURAL JOIN의 특징으로 옳은 것은?**

* ① 조인 컬럼에 테이블 별칭(Alias)을 사용할 수 없다.
* ② ON 절을 사용하여 조인 조건을 명시해야 한다.
* ③ 이름은 다르지만 타입이 같은 컬럼을 찾아 조인한다.
* ④ INNER JOIN보다 성능이 항상 우수하다.

> **정답**: ①
> **해설**: NATURAL JOIN은 자동으로 컬럼을 찾으므로 조인 컬럼에 식별자(E.DEPTNO 등)를 붙이면 에러가 납니다.
> **힌트**: 5일차 '공통 컬럼은 쿨하게 혼자' 파트를 확인하세요.

**14. LEFT OUTER JOIN에서 왼쪽 테이블에는 데이터가 있고 오른쪽 테이블에는 매칭되는 데이터가 없을 때 출력값은?**

* ① 해당 행은 출력되지 않는다.
* ② 에러가 발생한다.
* ③ 오른쪽 테이블의 컬럼값들이 NULL로 채워져 출력된다.
* ④ 왼쪽 테이블의 데이터도 삭제된다.

> **정답**: ③
> **해설**: 기준 테이블(왼쪽)의 데이터는 다 보여주되 짝이 없으면 빈칸(NULL)으로 나옵니다.
> **힌트**: 5일차 '구매 안 한 회원' 예시를 떠올려보세요.

**15. 다음 중 3개의 테이블을 조인할 때 필요한 최소 조인 조건의 개수는?**

* ① 1개
* ② 2개
* ③ 3개
* ④ 없음

> **정답**: ②
> **해설**: N개의 테이블을 조인하려면 최소 N-1개의 조건이 필요합니다.
> **힌트**: N-1의 법칙을 기억하세요.

---

### [PART 2] SQL 활용 (DAY 8 ~ 11)

**16. 다음 중 서브쿼리에 대한 설명으로 부적절한 것은?**

* ① 서브쿼리는 항상 괄호로 감싸야 한다.
* ② 단일 행 서브쿼리는 결과가 2건 이상이어도 상관없다.
* ③ 서브쿼리 내에서는 ORDER BY 절을 쓸 수 없다 (인라인 뷰 제외).
* ④ 서브쿼리는 메인쿼리의 컬럼을 참조할 수 있다.

> **정답**: ②
> **해설**: 단일 행 서브쿼리에 결과가 2건 이상 나오면 에러가 발생합니다.
> **힌트**: 8일차 단일 행 vs 다중 행 연산자를 구분하세요.

**17. 다음 중 다중 행 연산자가 아닌 것은?**

* ① IN
* ② ANY
* ③ <>
* ④ ALL

> **정답**: ③
> **해설**: `<>`는 단일 행 비교 연산자입니다.
> **힌트**: 8일차 다중 행 필수 암기 연산자 표를 확인하세요.

**18. 뷰(View)를 사용하는 장점 중 '보안성'과 관련 있는 것은?**

* ① 복잡한 쿼리를 단순화시킨다.
* ② 특정 컬럼을 제외하고 뷰를 생성하여 권한을 제어할 수 있다.
* ③ 원본 테이블 구조가 바뀌어도 영향을 받지 않는다.
* ④ 데이터 저장 공간을 절약할 수 있다.

> **정답**: ②
> **해설**: 민감한 정보(급여 등)를 빼고 뷰를 만들어 공개함으로써 보안을 유지합니다.
> **힌트**: '독·편·보'의 보안성입니다.

**19. 다음 중 집합 연산자 `UNION`과 `UNION ALL`의 결정적 차이는?**

* ① 합치는 데이터의 타입
* ② 결과의 중복 제거 여부 및 정렬 발생 여부
* ③ 컬럼의 개수 일치 여부
* ④ 사용 가능한 DBMS의 종류

> **정답**: ②
> **해설**: UNION은 중복을 제거하고 정렬을 수행하며, UNION ALL은 중복을 허용하고 정렬하지 않습니다.
> **힌트**: 정렬(Sort)은 성능에 영향을 줍니다.

**20. `ROLLUP(A, B)` 실행 시 집계되는 조합으로 옳은 것은?**

* ① (A, B), (A), ()
* ② (A, B), (B), ()
* ③ (A), (B), ()
* ④ (A, B), (A), (B), ()

> **정답**: ①
> **해설**: ROLLUP은 계층적으로 오른쪽 컬럼부터 하나씩 빼면서 집계합니다.
> **힌트**: 9일차 ROLLUP 공식 (A+B -> A -> 총계)을 기억하세요.

**21. 다음 중 순위 함수 3대장의 설명으로 틀린 것은?**

* ① `RANK`: 1, 1, 3 순위 부여 (건너뜀)
* ② `DENSE_RANK`: 1, 1, 2 순위 부여 (빽빽함)
* ③ `ROW_NUMBER`: 1, 2, 3 순위 부여 (무조건 다름)
* ④ `RANK`: 반드시 `PARTITION BY`가 있어야 실행된다.

> **정답**: ④
> **해설**: PARTITION BY는 선택 사항이며, 없으면 전체 데이터 기준입니다.
> **힌트**: 10일차 올림픽 메달 비유를 떠올려보세요.

**22. `ROWS`와 `RANGE`의 차이점에 대한 설명으로 옳은 것은?**

* ① `ROWS`는 값의 크기를 기준으로 범위를 정한다.
* ② `RANGE`는 물리적인 행의 수를 기준으로 범위를 정한다.
* ③ `RANGE`는 동일한 값이 있을 경우 한꺼번에 처리한다.
* ④ `ORDER BY`가 있으면 무조건 `ROWS`가 기본값이다.

> **정답**: ③
> **해설**: RANGE는 논리적 값 기준이므로 값이 같으면 동시에 누적 연산됩니다.
> **힌트**: 10일차 100원, 100원 입금 사례를 확인하세요.

**23. 윈도우 함수에서 이전 행의 값을 가져오는 함수는?**

* ① LEAD
* ② LAG
* ③ FIRST_VALUE
* ④ NTILE

> **정답**: ②
> **해설**: LAG는 이전(과거) 행, LEAD는 다음(미래) 행의 값을 가져옵니다.
> **힌트**: Lagging(뒤처짐)은 과거를 의미합니다.

**24. Oracle에서 상위 5개의 데이터를 추출하기 위해 가장 적절한 방법은?**

```sql
-- (A)
SELECT * FROM EMP WHERE ROWNUM <= 5 ORDER BY SAL DESC;
-- (B)
SELECT * FROM (SELECT * FROM EMP ORDER BY SAL DESC) WHERE ROWNUM <= 5;

```

* ① (A)가 맞다.
* ② (B)가 맞다.
* ③ 둘 다 결과가 같다.
* ④ 둘 다 틀렸다.

> **정답**: ②
> **해설**: ROWNUM은 행 추출 시 번호가 매겨지므로, 정렬을 먼저 수행한 서브쿼리 결과를 대상으로 잘라야 합니다.
> **힌트**: 11일차 ROWNUM '문 앞 번호표' 비유를 확인하세요.

**25. 다음 계층형 질의에서 순방향 전개(부모->자식)를 의미하는 것은?**

* ① `CONNECT BY PRIOR EMPNO = MGR`
* ② `CONNECT BY EMPNO = PRIOR MGR`
* ③ `START WITH MGR IS NULL`
* ④ `ORDER SIBLINGS BY ENAME`

> **정답**: ①
> **해설**: `PRIOR 사번 = 관리자사번`은 방금 읽은 사람(부모)이 누군가의 관리자인 경우를 찾는 순방향입니다.
> **힌트**: PRIOR는 '직전에 읽은 데이터'입니다.

**26. 계층형 질의의 가상 컬럼 중 루트 노드(최상위)면 1, 그 하위면 2... 식으로 깊이를 나타내는 것은?**

* ① LEVEL
* ② CONNECT_BY_ISLEAF
* ③ SYS_CONNECT_BY_PATH
* ④ CONNECT_BY_ROOT

> **정답**: ①
> **해설**: LEVEL은 트리의 깊이를 나타내는 가상 컬럼입니다.
> **힌트**: 11일차 가상 컬럼 표를 확인하세요.

**27. 다음 중 셀프 조인(Self Join)이 반드시 필요한 상황은?**

* ① 사원 정보와 부서 정보를 합칠 때
* ② 한 테이블 내에서 사원과 그 사원의 매니저 정보를 함께 보고 싶을 때
* ③ 두 테이블의 교집합을 구할 때
* ④ 중복 데이터를 제거하고 싶을 때

> **정답**: ②
> **해설**: 매니저 정보도 사원 테이블 안에 있으므로 나 자신과 조인해야 합니다.
> **힌트**: 11일차 최대리(301)와 이부장(201) 사례를 떠올려보세요.

**28. `LAST_VALUE` 함수 사용 시 범위를 `UNBOUNDED FOLLOWING`까지 지정하지 않으면 발생하는 현상은?**

* ① 에러가 발생한다.
* ② 항상 전체의 마지막 값이 출력된다.
* ③ '현재 행'이 마지막 값으로 간주되어 출력된다.
* ④ NULL이 출력된다.

> **정답**: ③
> **해설**: 윈도우 기본 범위가 '현재 행'까지이므로 LAST_VALUE는 범위를 끝까지 열어주지 않으면 무의미해집니다.
> **힌트**: 10일차 🚨 LAST_VALUE의 배신 파트를 참고하세요.

**29. `NTILE(4)` 함수를 10개의 데이터에 적용했을 때 1그룹에 배정되는 행의 수는?**

* ① 2개
* ② 3개
* ③ 4개
* ④ 1개

> **정답**: ②
> **해설**: 10을 4로 나누면 몫이 2, 나머지가 2이므로 앞의 1, 2그룹에 하나씩 더 배정합니다. (3, 3, 2, 2)
> **힌트**: 나머지는 앞 조부터 한 명씩 더 채웁니다.

**30. 계층형 질의에서 동일 레벨(형제 노드)끼리만 정렬하기 위해 사용하는 구문은?**

* ① ORDER BY
* ② GROUP BY
* ③ ORDER SIBLINGS BY
* ④ CONNECT BY PRIOR

> **정답**: ③
> **해설**: 계층 구조를 깨지 않으면서 형제들끼리만 정렬할 때 사용합니다.
> **힌트**: SIBLINGS는 형제자매라는 뜻입니다.

---

### [PART 3] 고급 SQL & 관리 구문 (DAY 12 ~ 13)

**31. `PIVOT` 함수에 대한 설명으로 옳은 것은?**

* ① 열을 행으로 변환한다.
* ② 행 데이터를 열로 회전시켜 요약 보고서를 만든다.
* ③ 중복된 행을 제거한다.
* ④ 데이터를 정규화할 때 주로 사용한다.

> **정답**: ②
> **해설**: PIVOT은 Long 데이터를 Wide하게 변환하는 행-열 전환 함수입니다.
> **힌트**: 12일차 엑셀 피벗 리포트 비유를 확인하세요.

**32. 정규표현식 메타 문자 중 '임의의 한 문자'를 의미하는 것은?**

* ① *
* ② +
* ③ .
* ④ ?

> **정답**: ③
> **해설**: 마침표(.)는 어떤 문자든 딱 한 글자를 의미합니다.
> **힌트**: 12일차 메타 문자 암기 표를 확인하세요.

**33. `REGEXP_LIKE(ENAME, '^A')`의 의미는?**

* ① 이름에 A가 포함된 사원
* ② 이름이 A로 끝나는 사원
* ③ 이름이 A로 시작하는 사원
* ④ 이름의 두 번째 글자가 A인 사원

> **정답**: ③
> **해설**: `^`는 문자열의 시작을 의미합니다.
> **힌트**: `$`는 끝, `^`는 시작입니다.

**34. 다음 중 DML(데이터 조작어)에 해당하지 않는 것은?**

* ① INSERT
* ② UPDATE
* ③ TRUNCATE
* ④ DELETE

> **정답**: ③
> **해설**: TRUNCATE는 DDL(데이터 정의어)로 분류됩니다.
> **힌트**: 13일차 명령어 분류 표를 확인하세요.

**35. `DELETE`, `TRUNCATE`, `DROP`에 대한 설명으로 틀린 것은?**

* ① `DELETE`는 로그를 남기므로 속도가 가장 느리다.
* ② `TRUNCATE`는 복구(ROLLBACK)가 불가능하다.
* ③ `DROP`은 테이블의 구조까지 완전히 삭제한다.
* ④ `TRUNCATE`는 `WHERE` 절을 사용하여 일부 데이터만 지울 수 있다.

> **정답**: ④
> **해설**: TRUNCATE는 테이블 전체를 초기화하는 명령어로 별도의 조건을 걸 수 없습니다.
> **힌트**: 13일차 3대 삭제 명령어 비교 표를 확인하세요.

**36. 트랜잭션의 특성 중 'All or Nothing'을 의미하는 것은?**

* ① 원자성(Atomicity)
* ② 일관성(Consistency)
* ③ 고립성(Isolation)
* ④ 지속성(Durability)

> **정답**: ①
> **해설**: 트랜잭션 내 연산은 모두 성공하거나 전혀 실행되지 않아야 합니다.
> **힌트**: 원자는 더 이상 쪼갤 수 없는 최소 단위입니다.

**37. Oracle 환경에서 DML을 수행한 직후 `CREATE TABLE`을 실행하고 `ROLLBACK`을 하면 어떤 결과가 발생하는가?**

* ① DML 결과가 취소된다.
* ② DDL 실행 시 자동 커밋이 발생하여 DML 결과가 취소되지 않는다.
* ③ 에러가 발생한다.
* ④ DDL만 취소된다.

> **정답**: ②
> **해설**: Oracle에서 DDL은 실행 전후로 자동 COMMIT을 발생시킵니다.
> **힌트**: 13일차 🚨 실전 오답 포인트 1번을 확인하세요.

**38. 다음 중 제약조건(Constraint)에 대한 설명으로 부적절한 것은?**

* ① `PRIMARY KEY`는 NULL을 허용하지 않는다.
* ② `UNIQUE KEY`는 NULL 값을 허용한다.
* ③ `FOREIGN KEY`는 참조 무결성을 지키기 위해 사용한다.
* ④ 한 테이블에 `PRIMARY KEY`를 여러 개 설정할 수 있다.

> **정답**: ④
> **해설**: 기본키(PK)는 테이블당 오직 1개만 설정 가능합니다.
> **힌트**: 식별자는 단 하나여야 합니다.

**39. `MERGE` 문에 대한 설명으로 옳은 것은?**

* ① 데이터를 삭제하는 용도로만 사용한다.
* ② 조건에 따라 `INSERT`와 `UPDATE`를 한 번에 수행한다.
* ③ `ROLLBACK`이 불가능한 DDL 문장이다.
* ④ 오직 하나의 테이블만 사용할 수 있다.

> **정답**: ②
> **해설**: 두 테이블을 비교하여 데이터가 있으면 수정, 없으면 삽입합니다.
> **힌트**: 13일차 1.2 심화 DML 파트를 확인하세요.

**40. 권한을 부여하는 DCL 명령어는?**

* ① REVOKE
* ② GRANT
* ③ COMMIT
* ④ ROLLBACK

> **정답**: ②
> **해설**: GRANT는 권한 부여, REVOKE는 권한 회수입니다.
> **힌트**: Grant는 '주다/승인하다'는 뜻입니다.

**41. `SAVEPOINT`에 대한 설명으로 옳은 것은?**

* ① 전체 트랜잭션을 확정 짓는 지점이다.
* ② `ROLLBACK TO 지점명`을 통해 특정 시점까지만 복구할 수 있다.
* ③ `COMMIT` 후에도 `SAVEPOINT`로 돌아갈 수 있다.
* ④ SQL Server에서만 지원하는 기능이다.

> **정답**: ②
> **해설**: 트랜잭션을 작게 쪼개어 부분 복구를 가능하게 합니다. COMMIT 후에는 트랜잭션이 종료되어 복구할 수 없습니다.
> **힌트**: 게임의 '세이브 포인트'와 같습니다.

**42. 다음 중 고유키(UNIQUE KEY)가 걸린 컬럼에 `NULL, NULL`을 입력하려고 할 때의 결과는? (Oracle 기준)**

* ① 중복 에러가 발생한다.
* ② 에러 없이 입력된다.
* ③ 하나의 NULL만 입력되고 나머지는 거부된다.
* ④ 자동으로 0으로 변환되어 입력된다.

> **정답**: ②
> **해설**: NULL은 값이 없는 상태이므로 중복 체크 대상이 아닙니다. 여러 개의 NULL 입력이 가능합니다.
> **힌트**: 13일차 3.2 제약조건 파트를 확인하세요.

**43. `DROP TABLE` 시 다른 테이블에서 참조 중인 외래키 제약조건까지 함께 삭제하며 테이블을 지우는 옵션은?**

* ① CASCADE CONSTRAINTS
* ② DELETE ALL
* ③ TRUNCATE
* ④ FORCE

> **정답**: ①
> **해설**: 부모 테이블 삭제 시 자식의 외래키 제약조건을 함께 날려버리는 옵션입니다.
> **힌트**: 폭포처럼 연결된 것을 지우는 CASCADE입니다.

**44. 효율적인 권한 관리를 위해 여러 권한을 하나로 묶어 관리하는 개념은?**

* ① GROUP
* ② ROLE
* ③ PACKAGE
* ④ BUNDLE

> **정답**: ②
> **해설**: ROLE(롤)을 생성하여 권한을 담고 이를 사용자에게 부여합니다.
> **힌트**: 13일차 4.2 ROLE 파트를 확인하세요.

**45. 다음 정규표현식의 의미로 적절한 것은? "^[0-9]+$"**`

* ① 숫자로 시작하거나 끝나는 문자열
* ② 오직 숫자로만 구성된 문자열
* ③ 숫자가 포함되지 않은 문자열
* ④ 첫 글자만 숫자인 문자열

> **정답**: ②
> **해설**: `^`(시작)부터 `$`(끝)까지 `[0-9]`(숫자)가 `+`(1개 이상) 있다는 뜻입니다.
> **힌트**: 전체가 숫자인지 검사하는 패턴입니다.

**46. `UNPIVOT`의 주된 사용 목적은?**

* ① 요약 보고서 작성
* ② Wide 데이터를 Long 데이터로 정규화
* ③ 중복 데이터 제거
* ④ 테이블 구조 변경(DDL)

> **정답**: ②
> **해설**: 여러 열로 나열된 데이터를 행으로 내려서 정규화된 형태를 만듭니다.
> **힌트**: PIVOT의 반대입니다.

**47. 다음 중 `NULLIF(A, B)`의 결과가 NULL인 경우는?**

* ① A가 NULL일 때
* ② B가 NULL일 때
* ③ A와 B가 같을 때
* ④ A와 B가 다를 때

> **정답**: ③
> **해설**: 두 값이 같으면 NULL을, 다르면 첫 번째 값(A)을 반환합니다.
> **힌트**: 3일차 NULL 처리 함수 표를 확인하세요.

**48. SQL Server에서 자동 커밋(Auto-Commit)을 방지하고 명시적 트랜잭션을 시작하는 명령어는?**

* ① START TRANSACTION
* ② BEGIN TRAN
* ③ SET COMMIT OFF
* ④ COMMIT

> **정답**: ②
> **해설**: SQL Server는 기본이 자동 커밋이므로 BEGIN TRAN으로 명시적 시작을 알립니다.
> **힌트**: 13일차 DBMS별 차이점을 확인하세요.

**49. 다음 중 `DELETE FROM EMP;` 실행 후의 상태로 옳은 것은?**

* ① 테이블 구조가 사라진다.
* ② 저장 공간이 즉시 반환된다.
* ③ `ROLLBACK`을 통해 데이터를 복구할 수 있다.
* ④ `COMMIT`을 하지 않아도 즉시 영구 반영된다(Oracle 기준).

> **정답**: ③
> **해설**: DELETE는 DML이므로 사용자가 확정 짓기 전까지는 롤백이 가능합니다.
> **힌트**: DML은 신중하게, 하지만 취소는 가능합니다.

**50. 다음 중 SQL 실행 순서가 가장 마지막인 것은?**

* ① WHERE
* ② SELECT
* ③ ORDER BY
* ④ HAVING

> **정답**: ③
> **해설**: 정렬(ORDER BY)은 모든 결과를 뽑아낸 후 가장 마지막에 수행됩니다.
> **힌트**: 프-웨-그-하-셀-오!
