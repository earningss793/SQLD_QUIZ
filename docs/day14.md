
## 📝 SQLD DAY 8~13 실전 대비 40문항 퀴즈

### **[DAY 8] 서브쿼리 & 뷰 (Subquery & View)**

**1. 다음 중 서브쿼리에 대한 설명으로 가장 부적절한 것은?**

* ① 서브쿼리는 메인쿼리의 컬럼을 사용할 수 있다.
* ② 서브쿼리는 항상 괄호 `()`로 감싸야 한다.
* ③ 서브쿼리 내에서는 원칙적으로 `ORDER BY` 절을 사용할 수 없다.
* ④ 메인쿼리는 서브쿼리의 컬럼을 자유롭게 사용할 수 있다.

> **정답**: ④
> **해설**: 서브쿼리는 메인쿼리의 컬럼을 쓸 수 있지만(상속), 메인쿼리는 서브쿼리의 컬럼을 직접 사용할 수 없습니다.
> **힌트**: 마트료시카 인형처럼 '안'에 있는 인형은 '밖'을 볼 수 있지만, '밖'에서는 '안'의 세부 컬럼이 안 보입니다.

**2. 다음 SQL의 실행 결과로 출력되는 행의 수는?**

```sql
SELECT * FROM EMP
WHERE DEPTNO NOT IN (SELECT DEPTNO FROM DEPT WHERE LOC IN ('NEW YORK', NULL));

```

* ① 0건
* ② DEPTNO가 10이 아닌 모든 행
* ③ NULL을 제외한 모든 행
* ④ 에러 발생

> **정답**: ①
> **해설**: `NOT IN` 연산자 뒤 서브쿼리 결과에 `NULL`이 포함되면 전체 메인쿼리 결과는 무조건 0건(Empty set)입니다.
> **힌트**: [DAY 8]의 'NOT IN + NULL' 함정을 기억하세요!

**3. 다음 중 스칼라 서브쿼리(Scalar Subquery)에 대한 설명으로 올바른 것은?**

* ① FROM 절에 사용되는 서브쿼리이다.
* ② 반드시 1행 1열의 단일 값을 반환해야 한다.
* ③ 결과가 2건 이상이어도 자동으로 첫 번째 행만 반환한다.
* ④ 주로 데이터의 삭제 성능을 높이기 위해 사용한다.

> **정답**: ②
> **해설**: 스칼라 서브쿼리는 SELECT 절에서 마치 하나의 '값(Scalar)'처럼 사용되므로 반드시 1행 1열만 반환해야 합니다.
> **힌트**: 1x1의 단일 값을 기억하세요.

**4. 뷰(View)의 특징 중 '독립성'에 대한 설명으로 옳은 것은?**

* ① 뷰 자체에 인덱스를 생성하여 조회 성능을 독립적으로 높일 수 있다.
* ② 테이블 구조가 변경되어도 뷰를 사용하는 어플리케이션은 수정할 필요가 없다.
* ③ 뷰는 물리적인 저장 공간을 독립적으로 차지하여 데이터를 보존한다.
* ④ 여러 테이블을 조인한 뷰는 항상 DML 작업이 독립적으로 가능하다.

> **정답**: ②
> **해설**: 논리적 데이터 독립성은 원본 테이블의 구조 변화를 뷰의 정의 수정을 통해 흡수함으로써 사용자에게 영향이 가지 않게 하는 것입니다.
> **힌트**: '독·편·보' 중 첫 번째 특징입니다.

**5. 다음 중 뷰(View)를 삭제할 때 발생하는 현상으로 옳은 것은?**

* ① 원본 테이블의 데이터도 함께 삭제된다.
* ② 뷰를 참조하고 있는 다른 뷰는 자동으로 업데이트된다.
* ③ 원본 테이블에는 영향을 주지 않고 뷰의 정의만 삭제된다.
* ④ 뷰를 삭제하려면 반드시 `ALTER VIEW` 명령어를 써야 한다.

> **정답**: ③
> **해설**: 뷰는 실체가 없는 가상 테이블이므로 삭제(`DROP VIEW`) 시 텍스트 정의만 사라지고 원본 데이터는 무사합니다.
> **힌트**: 실체(데이터)는 테이블에, 껍데기(정의)는 뷰에 있습니다.

---

### **[DAY 9] 집합 연산자 & 그룹 함수 (Set & Group)**

**6. 다음 중 `UNION`과 `UNION ALL`의 차이점에 대한 설명으로 부적절한 것은?**

* ① `UNION`은 결과에서 중복된 행을 제거한다.
* ② `UNION ALL`은 중복된 행을 포함하여 모든 결과를 보여준다.
* ③ `UNION`은 중복 제거를 위해 내부적으로 정렬을 수행한다.
* ④ `UNION ALL`은 정렬을 수행하므로 `UNION`보다 속도가 느리다.

> **정답**: ④
> **해설**: `UNION ALL`은 정렬과 중복 제거를 하지 않기 때문에 `UNION`보다 속도가 훨씬 빠릅니다.
> **힌트**: 정렬(Sort)은 DB에게 큰 부담을 주는 작업입니다.

**7. 아래 테이블 데이터에 대해 SQL을 실행했을 때 결과로 옳은 것은?**
[TABLE A: {1, 2, 2, 3}], [TABLE B: {2, 3, 4}]

```sql
SELECT ID FROM A
INTERSECT
SELECT ID FROM B;

```

* ① {2, 3}
* ② {1, 2, 3, 4}
* ③ {2, 2, 3}
* ④ {1}

> **정답**: ①
> **해설**: `INTERSECT`는 교집합이며, 집합 연산자는 기본적으로 중복을 제거한 결과를 반환합니다.
> **힌트**: 교집합을 구하고 중복을 지우세요.

**8. `GROUP BY ROLLUP(A, B)`의 결과와 동일한 집합을 생성하는 `GROUPING SETS` 구문은?**

* ① `GROUPING SETS(A, B, ())`
* ② `GROUPING SETS((A, B), (A), ())`
* ③ `GROUPING SETS((A, B), (B), ())`
* ④ `GROUPING SETS(A, B)`

> **정답**: ②
> **해설**: `ROLLUP(A, B)`는 (A, B) 상세, (A) 소계, () 전체 총계를 구합니다.
> **힌트**: 계층적 집계의 순서를 생각하세요 (A+B -> A -> All).

**9. 다음 중 `CUBE` 함수에 대한 설명으로 옳은 것은?**

* ① 인수의 순서가 바뀌면 결과의 집합 자체가 달라진다.
* ② 계층적인 구조로 소계만 산출한다.
* ③ 결합 가능한 모든 항목에 대해 다차원 집계를 수행한다.
* ④ `ROLLUP`보다 시스템 부하가 적어 실무에서 권장된다.

> **정답**: ③
> **해설**: `CUBE`는 개의 모든 조합을 집계하므로 시스템 부하가 매우 큽니다.
> **힌트**: '모든 경우의 수'가 키워드입니다.

**10. 아래 SQL에서 `GROUPING` 함수의 결과가 1인 행의 의미는?**

```sql
SELECT DEPTNO, GROUPING(DEPTNO), SUM(SAL)
FROM EMP GROUP BY ROLLUP(DEPTNO);

```

* ① 해당 행이 실제 데이터임을 의미한다.
* ① 해당 행이 집계(소계/총계)를 위해 생성된 행임을 의미한다.
* ③ 해당 컬럼에 실제 `NULL` 값이 들어있음을 의미한다.
* ④ 에러가 발생하여 처리되지 않았음을 의미한다.

> **정답**: ②
> **해설**: `GROUPING` 함수는 해당 컬럼이 집계에 사용되어 `NULL`로 표시된 경우 1을 반환합니다.
> **힌트**: 이름표를 달아줄 '집계 행'인지 확인하는 탐지기입니다.

**11. 다음 중 집합 연산자 사용 시 주의사항으로 틀린 것은?**

* ① SELECT 절의 컬럼 수가 동일해야 한다.
* ② 상천/하천 컬럼의 데이터 타입이 상호 호환되어야 한다.
* ③ ORDER BY 절은 각 SELECT 문마다 개별적으로 사용할 수 있다.
* ④ 출력되는 컬럼명은 첫 번째 SELECT 문의 컬럼명을 따른다.

> **정답**: ③
> **해설**: `ORDER BY`는 집합 연산의 맨 마지막에 단 한 번만 올 수 있습니다.
> **힌트**: 결과가 다 합쳐진 후에 마지막으로 줄을 세워야 합니다.

---

### **[DAY 10] 윈도우 함수 (Window Function) - ★빈출★**

**12. `RANK()`, `DENSE_RANK()`, `ROW_NUMBER()` 함수에 대한 설명으로 부적절한 것은?**

* ① `RANK`는 동일 순위가 있을 경우 다음 순위를 건너뛴다.
* ② `DENSE_RANK`는 동일 순위가 있어도 다음 순위를 연속해서 부여한다.
* ③ `ROW_NUMBER`는 동일한 값이라도 유일한 순위를 부여한다.
* ④ 세 함수 모두 `PARTITION BY` 절이 없으면 에러가 발생한다.

> **정답**: ④
> **해설**: `PARTITION BY`는 선택 사항입니다. 없으면 전체 데이터를 하나의 그룹으로 보고 순위를 매깁니다.
> **힌트**: 등수 매기는 법의 차이만 기억하세요.

**13. 다음 데이터를 기준으로 `SUM(AMT) OVER(ORDER BY DATE ROWS BETWEEN 1 PRECEDING AND CURRENT ROW)`의 3번째 행 결과값은?**
[Row1: 100], [Row2: 200], [Row3: 300]

* ① 600
* ② 500
* ③ 300
* ④ 400

> **정답**: ②
> **해설**: 현재 행(300)과 그 앞의 1개 행(200)을 더하므로 500입니다.
> **힌트**: `ROWS 1 PRECEDING`은 '나와 내 앞사람'입니다.

**14. 윈도우 함수의 기본 범위(Default Window Frame)에 대한 설명으로 옳은 것은?**

* ① `ORDER BY`가 없을 때: 처음부터 끝까지 (`ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING`)
* ② `ORDER BY`가 있을 때: 처음부터 현재 행까지 (`RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`)
* ③ `ORDER BY` 유무와 상관없이 항상 현재 행만 계산한다.
* ④ ①과 ② 모두 맞다.

> **정답**: ④
> **해설**: `ORDER BY`가 있으면 누적의 의미가 생겨 '현재 행까지'가 기본값이 됩니다.
> **힌트**: [DAY 10]의 🚨 주의사항 파트를 다시 보세요!

**15. `LAG`와 `LEAD` 함수에 대한 설명으로 옳은 것은?**

* ① `LAG`는 이후 행의 값을 가져온다.
* ② `LEAD`는 이전 행의 값을 가져온다.
* ③ `LAG(SAL, 1, 0)`에서 0은 가져올 값이 없을 때 출력할 기본값이다.
* ④ 두 함수는 반드시 `GROUP BY`와 함께 사용해야 한다.

> **정답**: ③
> **해설**: `LAG`는 이전(과거), `LEAD`는 이후(미래) 값을 가져옵니다. 3번째 인자는 `NULL` 대응 값입니다.
> **힌트**: Lagging(뒤처짐) = 과거, Lead(선도) = 미래.

**16. 다음 중 `RATIO_TO_REPORT` 함수의 용도는?**

* ① 파티션 내의 누적 백분율을 구한다.
* ② 전체 합계 대비 현재 행의 값의 비율을 구한다.
* ③ 현재 행과 앞뒤 행의 평균을 구한다.
* ④ 전체 데이터의 중앙값을 구한다.

> **정답**: ②
> **해설**: 리포트 비중을 구할 때 쓰는 함수입니다.
> **힌트**: 내 급여 / 전체 급여 합계.

**17. `NTILE(4)` 함수를 10개의 행에 적용했을 때, 각 그룹에 배정되는 행의 수로 옳은 것은?**

* ① 3, 3, 2, 2
* ② 2, 2, 3, 3
* ③ 4, 2, 2, 2
* ④ 3, 2, 2, 3

> **정답**: ①
> **해설**: 앞에서부터 남는 나머지를 하나씩 채웁니다. 10/4 = 2...2 이므로 앞의 두 그룹에 1개씩 더 추가합니다.
> **힌트**: 몫은 2, 나머지는 2. 앞에서부터 보너스!

**18. 윈도우 함수 사용 시 `ORDER BY` 절이 없을 때 `SUM(SAL) OVER()`의 결과는?**

* ① 누적 합계가 출력된다.
* ② 전체 행에 대해 동일한 전체 합계가 출력된다.
* ③ 에러가 발생한다.
* ④ 각 행의 `SAL` 값 자체가 출력된다.

> **정답**: ②
> **해설**: 순서가 없으면 어디까지가 현재인 지 알 수 없어 전체를 하나의 창문으로 봅니다.
> **힌트**: [DAY 10] 표: ORDER BY 없음 = Grand Total.

**19. `CUME_DIST` 함수에 대한 설명으로 옳은 것은?**

* ① 상대적 순위를 0~1 사이 값으로 반환한다.
* ② 누적 분포를 구하며, (나보다 작거나 같은 행 수 / 전체 행 수)로 계산한다.
* ③ 항상 0.5를 기준으로 대칭적인 값을 반환한다.
* ④ 데이터가 10개일 때 1등의 값은 항상 0.1이다.

> **정답**: ②
> **해설**: 누적 분포(Cumulative Distribution) 함수입니다.
> **힌트**: 나를 포함해서 나보다 상위권이 몇 명인가?

**20. `FIRST_VALUE`와 `LAST_VALUE` 사용 시 주의사항으로 옳은 것은?**

* ① `LAST_VALUE`는 항상 전체 파티션의 마지막 값을 정확히 가져온다.
* ② `LAST_VALUE` 사용 시 범위를 `UNBOUNDED FOLLOWING`까지 지정하지 않으면 현재 행이 마지막 값이 된다.
* ③ `FIRST_VALUE`는 `ORDER BY` 절이 없어도 사용 가능하다.
* ④ 두 함수는 수치형 데이터에만 사용할 수 있다.

> **정답**: ②
> **해설**: 윈도우 기본 범위가 '현재 행까지'이므로 `LAST_VALUE`는 범위 지정이 필수입니다.
> **힌트**: 🚨 [시험 빈출] LAST_VALUE의 배신!

**21. 다음 중 윈도우 함수를 사용할 수 없는 곳은?**

* ① SELECT 절
* ② UPDATE 문의 SET 절 (서브쿼리 내)
* ③ WHERE 절
* ④ ORDER BY 절

> **정답**: ③
> **해설**: 윈도우 함수는 결과가 추출된 후 포스트잇처럼 붙는 기능이라 `WHERE` 절에서 필터링 조건으로 쓸 수 없습니다.
> **힌트**: 순위로 자르려면 서브쿼리(인라인 뷰)를 거쳐야 합니다.

---

### **[DAY 11] 고급 질의 (Top N, Self Join, Hierarchical) - ★빈출★**

**22. Oracle에서 `SELECT * FROM EMP WHERE ROWNUM = 2` 실행 시 결과는?**

* ① 2번째 행이 출력된다.
* ② 에러가 발생한다.
* ③ 아무 행도 출력되지 않는다 (0건).
* ④ 전체 행이 출력된다.

> **정답**: ③
> **해설**: `ROWNUM`은 1이 먼저 선택되어야 2가 존재할 수 있습니다. 1이 없으면 2를 찾을 수 없습니다.
> **힌트**: [DAY 11] ROWNUM의 '1'의 법칙.

**23. 다음 중 계층형 질의에서 `PRIOR` 키워드에 대한 설명으로 옳은 것은?**

* ① `PRIOR 자식 = 부모` 형태는 위에서 아래로 내려가는 순방향 전개이다.
* ② `PRIOR 부모 = 자식` 형태는 아래에서 위로 올라가는 역방향 전개이다.
* ③ `PRIOR`는 '직전에 읽은 데이터'를 의미한다.
* ④ `PRIOR`는 반드시 `START WITH` 절에만 사용해야 한다.

> **정답**: ③
> **해설**: `PRIOR`는 이전 단계의 값을 참조합니다. `PRIOR 부모 = 자식`이 순방향입니다.
> **힌트**: 사장님(PRIOR)의 번호가 내 상사 번호인 녀석들 나와라! (순방향)

**24. 계층형 질의의 가상 컬럼 중 말단 노드(자식이 없는 노드)를 판별하는 것은?**

* ① `LEVEL`
* ② `CONNECT_BY_ISLEAF`
* ③ `SYS_CONNECT_BY_PATH`
* ④ `CONNECT_BY_ROOT`

> **정답**: ②
> **해설**: 나뭇잎(Leaf)은 트리의 끝을 의미합니다. 끝이면 1을 반환합니다.
> **힌트**: Leaf = 말단 사원.

**25. 다음 SQL의 실행 결과로 가장 적절한 것은?**

```sql
SELECT ENAME FROM EMP
START WITH ENAME = 'KING'
CONNECT BY PRIOR EMPNO = MGR
ORDER SIBLINGS BY ENAME;

```

* ① 전체 사원을 이름순으로 정렬한다.
* ② 계층 구조를 유지하면서 동일 레벨의 형제들끼리만 이름순으로 정렬한다.
* ③ 'KING'의 부하직원들만 이름 역순으로 정렬한다.
* ④ 에러가 발생한다.

> **정답**: ②
> **해설**: `ORDER SIBLINGS BY`는 계층 트리를 깨뜨리지 않고 형제 노드 내에서만 정렬합니다.
> **힌트**: 족보 순서를 지키면서 형제끼리 키순으로 서기.

**26. 셀프 조인(Self Join) 시 반드시 필요한 것은?**

* ① 테이블의 별칭(Alias)
* ② `UNION` 연산자
* ③ 외부 조인(Outer Join) 구문
* ④ `CONNECT BY` 절

> **정답**: ①
> **해설**: 동일한 테이블을 두 번 호출하므로 구분하기 위한 별칭이 필수입니다.
> **힌트**: 나와 나의 상사를 구분할 '가면(Alias)'이 필요합니다.

**27. `START WITH` 절에 대한 설명으로 옳은 것은?**

* ① 생략할 경우 전체 행을 루트로 보고 계층을 전개한다.
* ② 반드시 `NULL` 값만 조건으로 줄 수 있다.
* ③ 계층 전개의 종료 조건을 기술한다.
* ④ `CONNECT BY` 절보다 뒤에 위치해야 한다.

> **정답**: ①
> **해설**: `START WITH`는 시작점이며, 생략 가능합니다.
> **힌트**: 어디서부터 족보를 시작할 것인가?

**28. `SYS_CONNECT_BY_PATH(ENAME, '/')`의 결과값 예시로 옳은 것은?**

* ① /KING/BLAKE/ALLEN
* ② KING-BLAKE-ALLEN
* ③ ALLEN/BLAKE/KING
* ④ /ALLEN

> **정답**: ①
> **해설**: 루트부터 현재 행까지의 경로를 구분자와 함께 보여줍니다.
> **힌트**: 파일 탐색기 주소창과 비슷합니다.

**29. `CONNECT BY` 절에서 `NOCYCLE` 옵션의 역할은?**

* ① 계층 전개 속도를 높인다.
* ② 무한 루프(Cycle)가 발생했을 때 에러를 내지 않고 중단한다.
* ③ 리프 노드만 출력한다.
* ④ 중복된 데이터를 제거한다.

> **정답**: ②
> **해설**: 부모가 자식이 되고 자식이 다시 부모가 되는 순환 구조를 방지합니다.
> **힌트**: Cycle = 뺑뺑이 방지.

**30. SQL Server에서 상위 5개의 행을 출력하는 올바른 구문은?**

* ① `SELECT * FROM EMP WHERE ROWNUM <= 5;`
* ② `SELECT TOP(5) * FROM EMP;`
* ③ `SELECT * FROM EMP FETCH FIRST 5 ROWS ONLY;`
* ④ `SELECT * FROM EMP LIMIT 5;`

> **정답**: ②
> **해설**: SQL Server는 `TOP` 절을 사용합니다.
> **힌트**: [DAY 11] 1.2 SQL Server: TOP 절.

**31. `OFFSET 5 ROWS FETCH NEXT 10 ROWS ONLY` 구문의 의미는?**

* ① 1행부터 10행까지 출력한다.
* ② 5행을 제외한 나머지 전체를 출력한다.
* ③ 앞의 5행을 건너뛰고 그 다음 10개의 행을 출력한다 (6~15행).
* ④ 5행과 10행만 출력한다.

> **정답**: ③
> **해설**: 페이징 처리의 표준 문법입니다.
> **힌트**: Offset(건너뛰기), Fetch(가져오기).

---

### **[DAY 12] PIVOT & 정규표현식 (PIVOT & Regex)**

**32. `PIVOT` 함수 사용 시 반드시 포함되어야 하는 요소는?**

* ① `GROUP BY` 절
* ② 집계 함수 (SUM, AVG 등)
* ③ `ORDER BY` 절
* ④ `CONNECT BY` 절

> **정답**: ②
> **해설**: 행과 열이 만나는 지점의 값을 요약할 집계 함수가 필수입니다.
> **힌트**: 엑셀 피벗 테이블을 만들 때 '값' 영역에 뭘 넣을지 생각하세요.

**33. 정규표현식 메타 문자 중 '문자열의 끝'을 의미하는 것은?**

* ① `^`
* ② `*`
* ③ `$`
* ④ `.`

> **정답**: ③
> **해설**: `^`는 시작, `$`는 끝입니다.
> **힌트**: `$money`는 돈의 끝(결과)이라고 외워보세요.

**34. `REGEXP_LIKE(ENAME, '^[A-C]')`의 결과로 옳은 것은?**

* ① 이름에 A, B, C가 포함된 모든 사원
* ② 이름이 A, B, 또는 C로 시작하는 사원
* ③ 이름이 A, B, 또는 C로 끝나는 사원
* ④ 이름이 정확히 'ABC'인 사원

> **정답**: ②
> **해설**: `^`는 시작, `[A-C]`는 A부터 C 사이의 문자 중 하나를 의미합니다.
> **힌트**: [DAY 12] 표: ^(시작), [](https://www.google.com/search?q=%ED%83%9D1).

**35. `UNPIVOT`에 대한 설명으로 옳은 것은?**

* ① 행을 열로 변환한다.
* ② 열을 행으로 변환한다.
* ③ 중복된 데이터를 제거한다.
* ④ 계층 구조를 시각화한다.

> **정답**: ②
> **해설**: PIVOT의 반대이며, Wide 데이터를 Long 데이터로 만듭니다.
> **힌트**: 펼쳐진 컬럼들을 다시 아래로 쌓기.

---

### **[DAY 13] 관리 구문 (DML, TCL, DDL, DCL)**

**36. 다음 중 DDL에 해당하는 명령어로만 짝지어진 것은?**

* ① CREATE, ALTER, INSERT
* ② UPDATE, DELETE, MERGE
* ③ CREATE, DROP, TRUNCATE
* ④ GRANT, REVOKE, COMMIT

> **정답**: ③
> **해설**: DDL은 구조를 정의하는 CREATE, ALTER, DROP, TRUNCATE 등입니다.
> **힌트**: [DAY 13] 3.1 DDL 명령어 종류.

**37. `DELETE`, `TRUNCATE`, `DROP`에 대한 설명으로 틀린 것은?**

* ① `DELETE`는 `ROLLBACK`이 가능하다.
* ② `TRUNCATE`는 테이블의 구조는 남기고 데이터만 삭제한다.
* ③ `DROP`은 테이블 자체를 삭제하며 복구가 불가능하다.
* ④ `TRUNCATE`는 `DELETE`보다 속도가 느리지만 안전하다.

> **정답**: ④
> **해설**: `TRUNCATE`는 로그를 남기지 않아 `DELETE`보다 압도적으로 빠릅니다.
> **힌트**: 속도는 TRUNCATE > DELETE.

**38. 트랜잭션의 특성 중 'All or Nothing'을 의미하는 것은?**

* ① 원자성(Atomicity)
* ② 일관성(Consistency)
* ③ 고립성(Isolation)
* ④ 지속성(Durability)

> **정답**: ①
> **해설**: 트랜잭션 내의 작업은 모두 성공하거나 모두 실패해야 합니다.
> **힌트**: 원자는 더 이상 쪼갤 수 없는 최소 단위입니다.

**39. Oracle에서 DML 수행 후 `CREATE TABLE`을 실행했을 때 발생하는 현상은?**

* ① 이전 DML 내역이 `ROLLBACK` 된다.
* ② DDL 실행 직전에 자동 `COMMIT`이 발생한다.
* ③ 에러가 발생하여 DDL이 실행되지 않는다.
* ④ 사용자가 명시적으로 `COMMIT`을 할 때까지 대기한다.

> **정답**: ②
> **해설**: Oracle에서 DDL은 실행 전후로 자동 커밋을 일으킵니다.
> **힌트**: DDL은 무서운 녀석입니다. 실행 즉시 과거를 확정 짓습니다.

**40. `MERGE` 문에 대한 설명으로 부적절한 것은?**

* ① 조건에 따라 `INSERT`와 `UPDATE`를 동시에 처리할 수 있다.
* ② `WHEN MATCHED` 절은 조건이 일치할 때 실행된다.
* ③ `WHEN NOT MATCHED` 절은 반드시 생략해야 한다.
* ④ `UPDATE` 절 내에서 `DELETE`를 함께 사용할 수도 있다.

> **정답**: ③
> **해설**: `WHEN NOT MATCHED`는 조건이 맞지 않을 때 신규 삽입을 위해 주로 사용되며, 선택 사항입니다.
> **힌트**: 있으면 UPDATE, 없으면 INSERT.

