
## 📝 SQLD 1과목: 데이터 모델링 마스터 20제

### Q1. 모델링의 3대 특징과 3단계에 대한 설명 중 옳은 것을 모두 고르시오.

| 구분 | 내용 |
| --- | --- |
| **ㄱ** | 모델링의 특징은 추상화, 단순화, 명확화(추·단·명)이다. |
| **ㄴ** | 개념적 모델링은 특정 DBMS(Oracle, MySQL 등)에 종속적으로 수행된다. |
| **ㄷ** | 논리적 모델링 단계에서 정규화를 수행하여 데이터의 재사용성을 높인다. |
| **ㄹ** | 물리적 모델링은 성능, 저장 공간, 인덱스 등을 고려하여 설계한다. |

① ㄱ, ㄴ

② ㄱ, ㄷ, ㄹ

③ ㄴ, ㄷ, ㄹ

④ ㄱ, ㄴ, ㄷ, ㄹ

* **정답:** ②
* **힌트:** DBMS 기종을 고르는 단계는 가장 마지막 단계인 '물리적 모델링'입니다.
* **해설:** 개념적 모델링은 가장 추상적인 단계로 특정 DBMS를 고려하지 않습니다.

---

### Q2. 다음 중 ANSI-SPARC의 3층 스키마 구조에 대한 설명으로 부적절한 것은?

| 스키마 | 설명 |
| --- | --- |
| **외부 스키마** | 사용자나 응용 프로그램의 관점에서 보는 뷰 |
| **개념 스키마** | 모든 사용자의 관점을 통합한 조직 전체의 DB 구조 |
| **내부 스키마** | 물리적 저장 장치에서 데이터가 실제 저장되는 방식 |

① 외부 스키마는 하나의 DB에 여러 개 존재할 수 있다.

② 개념 스키마는 DBA(관리자)가 관리하며, 전체 DB에 오직 하나만 존재한다.

③ 물리적 데이터 독립성은 외부 스키마와 개념 스키마 사이의 관계에서 발생한다.

④ 내부 스키마는 인덱스, 데이터 압축, 해싱 구조 등을 정의한다.

* **정답:** ③
* **힌트:** '물리적'이라는 말이 들어가면 '내부 스키마'와 관련이 있습니다.
* **해설:** 물리적 데이터 독립성은 개념 스키마와 내부 스키마 사이의 사상(Mapping)을 통해 보장됩니다.

---

### Q3. 엔터티(Entity)의 성립 조건에 대한 보기 중 옳은 내용을 모두 고른 것은?

> **[보기]** > ㄱ. 해당 업무에서 반드시 필요하고 관리하고자 하는 정보여야 한다.
> ㄴ. 엔터티는 반드시 1개 이상의 인스턴스를 가져야 한다.
> ㄷ. 반드시 2개 이상의 속성을 가져야 한다.
> ㄹ. 다른 엔터티와 최소 1개 이상의 관계가 있어야 한다(단, 통계/코드성 제외).

① ㄱ, ㄴ, ㄷ

② ㄱ, ㄷ, ㄹ

③ ㄴ, ㄷ, ㄹ

④ ㄱ, ㄴ, ㄷ, ㄹ

* **정답:** ②
* **힌트:** '집합'이 되려면 데이터가 몇 줄 이상 있어야 할까요?
* **해설:** 엔터티는 반드시 2개 이상의 인스턴스(행)를 가져야 집합으로서 의미가 있습니다.

---

### Q4. 다음 엔터티 분류 표에서 (A), (B), (C)에 들어갈 용어가 바르게 연결된 것은?

| 분류 기준 | 엔터티 예시 | 구분명 |
| --- | --- | --- |
| 형태별 | 사원, 물품, 강사 | (A) |
| 형태별 | 주문, 매출, 입금 | (B) |
| 발생시점별 | 고객, 부서, 사원 | (C) |

① (A): 개념 엔터티, (B): 사건 엔터티, (C): 중심 엔터티

② (A): 유형 엔터티, (B): 사건 엔터티, (C): 기본 엔터티

③ (A): 유형 엔터티, (B): 개념 엔터티, (C): 행위 엔터티

④ (A): 사건 엔터티, (B): 유형 엔터티, (C): 기본 엔터티

* **정답:** ②
* **힌트:** 눈에 보이는 것(유형), 일어나는 일(사건), 가장 뿌리가 되는 것(기본)을 생각하세요.
* **해설:** (A)는 물리적 형태가 있는 유형 엔터티, (B)는 업무 수행에 따라 발생하는 사건 엔터티, (C)는 독립적으로 생성되는 기본(Key) 엔터티입니다.

---

### Q5. 아래 속성(Attribute)에 대한 설명 중 틀린 것을 고르시오.

| 속성 유형 | 예시 |
| --- | --- |
| **기본 속성** | 이름, 주소, 생년월일 |
| **설계 속성** | 사번, 상품코드, 지점코드 |
| **파생 속성** | 합계, 평균, 재고량 |

① 속성은 업무에서 필요로 하는 인스턴스의 최소 데이터 단위이다.

② 설계 속성은 업무상 원래 존재하던 데이터를 그대로 가져온 것이다.

③ 파생 속성은 데이터 정합성 유지를 위해 가급적 적게 정의하는 것이 좋다.

④ 하나의 속성은 하나의 도메인(값의 범위)을 가진다.

* **정답:** ②
* **힌트:** '설계'라는 말은 모델링을 위해 '인위적으로' 만들었다는 뜻입니다.
* **해설:** 원래 존재하던 데이터는 '기본 속성'이며, 모델링의 편의를 위해 부여한 것은 '설계 속성'입니다.

---

### Q6. 도메인(Domain)에 대한 설명으로 옳은 것을 모두 고르시오.

> **[보기]** > ㄱ. 속성이 가질 수 있는 값의 범위(Data Type, Size)를 의미한다.
> ㄴ. 엔터티 내에서 속성 간의 관계를 정의한 것이다.
> ㄷ. 사용자 정의 데이터 타입을 통해 도메인을 명확히 할 수 있다.
> ㄹ. 관계형 데이터베이스에서 체크 제약조건(Check)으로 구현할 수 있다.

① ㄱ, ㄴ, ㄷ

② ㄱ, ㄷ, ㄹ

③ ㄴ, ㄷ, ㄹ

④ ㄱ, ㄴ, ㄹ

* **정답:** ②
* **힌트:** 도메인은 속성 간의 관계가 아니라, '개별 속성'이 가질 수 있는 값의 규칙입니다.
* **해설:** 도메인은 데이터 타입, 제약조건 등을 포함하는 개념입니다.

---

### Q7. 다음 중 관계(Relationship)의 표기법인 'Crow's Foot'의 해석으로 부적절한 것은?

| 기호 | 의미 |
| --- | --- |
| ** |  |
| **O | ** |
| **O <** | 0개 또는 여러 개 (Optional Many) |

① 기호 'O'가 표시된 쪽은 해당 엔터티의 참여가 필수적임을 의미한다.

② 기호 '<' (까마귀발) 모양은 1:N 관계에서 'Many' 쪽을 나타낸다.

③ 관계명은 현재형 동사로 기술하며, 능동/수동형 모두 존재할 수 있다.

④ 선택사양(Optionality)은 데이터가 존재하지 않을 수도 있음을 의미한다.

* **정답:** ①
* **힌트:** 원(O)은 '0'을 의미합니다. 데이터가 0개여도 된다는 건 필수일까요, 선택일까요?
* **해설:** 'O'는 선택 참여(Optional)를 의미하며, '|'가 필수 참여(Mandatory)를 의미합니다.

---

### Q8. 다음 중 주식별자의 특징(유·최·불·존)에 대한 설명으로 옳은 것은?

| 특징 | 내용 |
| --- | --- |
| **유일성** | 모든 인스턴스를 유일하게 구분해야 함 |
| **최소성** | 유일성을 만족하는 최소한의 속성으로 구성되어야 함 |
| **불변성** | 식별자 값은 한 번 정해지면 바뀌지 않아야 함 |
| **존재성** | 주식별자는 반드시 값이 존재해야 함 (Not Null) |

① 주식별자가 여러 속성으로 구성된 복합식별자일 경우 최소성을 위배한 것이다.

② 사원 엔터티의 '이름'은 중복 가능성이 낮으므로 주식별자로 적합하다.

③ 주식별자 값은 업무적 이유로 언제든지 수정될 수 있어야 한다.

④ 후보키 중 업무 대표성을 가진 키를 주식별자로 선정한다.

* **정답:** ④
* **힌트:** 유일성과 최소성을 만족하는 것들을 '후보키'라고 부릅니다.
* **해설:** 복합식별자라도 유일성을 위해 꼭 필요하다면 최소성을 만족하는 것이며, 이름은 중복 가능성 및 불변성 문제로 주식별자에 부적합합니다.

---

### Q9. 다음 중 식별자의 계층 구조에 대한 설명으로 틀린 것은?

> **[관계도]** > 슈퍼키 $\supset$ 후보키 $\supset$ (주식별자, 대체키)

① 모든 후보키는 슈퍼키의 속성을 가진다.

② 슈퍼키는 유일성은 만족하지만 최소성은 만족하지 못할 수 있다.

③ 대체키는 후보키 중 주식별자로 선택되지 않은 나머지 키들이다.

④ 외래키(FK)는 해당 엔터티 내에서 반드시 유일한 값을 가져야 한다.

* **정답:** ④
* **힌트:** 부모 테이블의 PK를 참조하는 자식 테이블의 FK에 데이터가 여러 줄 쌓일 수 있을까요?
* **해설:** 외래키(FK)는 부모의 주식별자를 참조하는 것이며, 1:N 관계에서 N쪽의 FK는 중복된 값을 가질 수 있습니다.

---

### Q10. 식별자 관계(Solid Line)와 비식별자 관계(Dashed Line)에 대한 설명 중 옳은 것은?

| 구분 | 식별자 관계 | 비식별자 관계 |
| --- | --- | --- |
| 연결 형태 | 실선 | 점선 |
| 상속 방식 | 부모 PK가 자식 PK로 상속 | 부모 PK가 자식 일반속성으로 상속 |

① 비식별자 관계는 부모 없이 자식이 존재할 수 없는 강한 연결이다.

② 식별자 관계가 많아지면 자식 엔터티의 주식별자 속성 수가 계속 늘어난다.

③ 비식별자 관계를 사용하면 SQL 작성 시 조인(Join)의 횟수가 줄어든다.

④ 두 엔터티의 생명주기가 완전히 일치할 때 비식별자 관계를 권장한다.

* **정답:** ②
* **힌트:** 부모의 PK가 자식의 PK에 '포함'되는지, 그냥 '참고'만 하는지 생각해보세요.
* **해설:** 식별자 관계는 부모의 PK를 자식의 PK로 가져오므로, 계층이 깊어질수록 자식의 PK 속성이 누적되어 복잡해집니다.

---

### Q11. 제1정규화(1NF)를 위반한 사례와 해결책으로 옳은 것을 모두 고르시오.

| 학번 | 이름 | 수강과목 |
| --- | --- | --- |
| 202601 | 어닝쓰 | SQLD, 그로스마케팅 |

> **[보기]** > ㄱ. 위 테이블은 '수강과목' 속성이 다중값(Multi-value)을 가지므로 1NF 위반이다.
> ㄴ. 해결을 위해 '수강과목' 속성을 '수강과목1', '수강과목2'로 분리해야 한다.
> ㄷ. 해결을 위해 각 과목을 별도의 인스턴스(행)로 분리해야 한다.
> ㄹ. 속성의 원자성을 확보하는 것이 제1정규화의 핵심이다.

① ㄱ, ㄴ, ㄹ

② ㄱ, ㄷ, ㄹ

③ ㄴ, ㄷ, ㄹ

④ ㄱ, ㄹ

* **정답:** ②
* **힌트:** '수강과목1, 2'로 옆으로 늘리는 것도 정규화 위반(반복 그룹)입니다.
* **해설:** 하나의 속성에는 반드시 하나의 값(원자값)만 들어가야 합니다.

---

### Q12. 다음 중 제2정규화(2NF)의 대상이 되는 관계는?

| 엔터티 구성 | 예시 설명 |
| --- | --- |
| **PK (복합키)** | {주문번호, 상품코드} |
| **일반 속성 1** | 주문수량 (주문번호+상품코드에 의해 결정) |
| **일반 속성 2** | 상품명 (상품코드에 의해서만 결정) |

① 완전 함수 종속

② 이행 함수 종속

③ 부분 함수 종속

④ 다치 종속

* **정답:** ③
* **힌트:** PK가 두 개 이상의 속성일 때, 그 중 '일부'에만 종속되는 경우입니다.
* **해설:** '상품명'이 PK 전체가 아닌 '상품코드'에만 종속되므로 부분 함수 종속이며, 이를 분리하는 것이 2NF입니다.

---

### Q13. 제3정규화(3NF)에 대한 설명 중 옳은 것은?

> **[사원 테이블 구조]** > 사번(PK) $\rightarrow$ 부서코드 $\rightarrow$ 부서명

① 주식별자가 아닌 일반 속성 간의 종속성을 제거하는 과정이다.

② 결정자가 후보키가 아닌 함수 종속을 제거하는 과정이다.

③ 부분 함수 종속성을 제거하여 완전 함수 종속으로 만드는 과정이다.

④ 3정규화를 수행하면 조회(Join) 성능이 항상 향상된다.

* **정답:** ①
* **힌트:** A -> B -> C 처럼 꼬리에 꼬리를 무는 이행적 종속을 찾으세요.
* **해설:** 일반 속성(부서코드)이 다른 일반 속성(부서명)을 결정하는 이행 함수 종속을 제거하는 것이 3NF입니다.

---

### Q14. 정규화와 성능의 관계에 대한 설명으로 부적절한 것은?

| 정규화 여부 | 입력/수정/삭제 성능 | 조회(Join) 성능 |
| --- | --- | --- |
| **정규화 수행** | 향상 | 저하 가능성 있음 |

① 정규화는 데이터의 중복을 제거하여 무결성을 높인다.

② 정규화를 수행하면 테이블이 쪼개지므로 조인 발생으로 인한 성능 저하가 올 수 있다.

③ 조회 성능 향상을 위해 무조건 정규화를 생략해야 한다.

④ 정규화 이후 조회 성능이 심각하게 저하될 경우 반정규화를 고려한다.

* **정답:** ③
* **힌트:** 정규화는 DB 설계의 '기본'입니다. 생략이 아니라 수행 후 튜닝하는 것입니다.
* **해설:** 정규화는 기본적으로 수행하며, 성능 문제가 확실할 때만 전략적으로 반정규화를 수행합니다.

---

### Q15. 트랜잭션(Transaction)의 ACID 특성 중 "트랜잭션의 결과는 영구적으로 보존되어야 한다"는 것은?

① Atomicity (원자성)

② Consistency (일관성)

③ Isolation (고립성)

④ Durability (지속성)

* **정답:** ④
* **힌트:** 영어 단어의 뜻(내구성, 지속성)을 생각해보세요.
* **해설:** Commit된 데이터는 시스템 장애가 나도 보존되어야 한다는 원칙입니다.

---

### Q16. 다음 SQL 실행 결과에 대한 설명으로 옳은 것을 모두 고르시오.

```sql
-- 1단계: 데이터 10건 삭제
DELETE FROM EMP; 
-- 2단계: 저장점 생성
SAVEPOINT SP1;
-- 3단계: 데이터 5건 삽입
INSERT INTO EMP (ID) VALUES (1), (2), (3), (4), (5);
-- 4단계: 롤백 수행
ROLLBACK TO SP1;

```

> **[보기]** > ㄱ. 1단계에서 삭제된 10건의 데이터는 롤백으로 복구가 가능하다.
> ㄴ. 4단계 수행 후, 3단계에서 삽입한 5건의 데이터는 사라진다.
> ㄷ. DELETE 대신 TRUNCATE를 썼어도 결과는 동일하다.
> ㄹ. 최종적으로 DB에는 데이터가 0건인 상태(삭제된 상태)가 유지된다.

① ㄱ, ㄴ, ㄹ

② ㄱ, ㄷ, ㄹ

③ ㄴ, ㄷ

④ ㄱ, ㄴ, ㄷ, ㄹ

* **정답:** ①
* **힌트:** TRUNCATE는 DDL입니다. 롤백이 될까요?
* **해설:** DELETE는 롤백 가능하지만 TRUNCATE는 자동 커밋되어 복구가 불가합니다. ROLLBACK TO SP1을 하면 SP1 시점(삭제 직후)으로 돌아가므로 삽입된 5건은 사라집니다.

---

### Q17. NULL 값의 연산 규칙에 대한 설명 중 틀린 것은?

| 식 | 결과 |
| --- | --- |
| **100 + NULL** | (A) |
| **NULL = NULL** | (B) |

① (A)의 결과는 NULL이다.

② (B)의 결과는 참(TRUE)이다.

③ NULL과의 모든 산술 연산 결과는 NULL이다.

④ NULL과의 비교 연산(=, <, > 등)은 항상 알 수 없음(Unknown/False)을 반환한다.

* **정답:** ②
* **힌트:** NULL은 '모르는 값'입니다. 모르는 값과 모르는 값이 같다고 확신할 수 있나요?
* **해설:** NULL은 비교 연산자로 비교할 수 없으며, 반드시 `IS NULL`을 사용해야 합니다.

---

### Q18. 다음 집계 함수와 NULL의 관계에 대한 설명으로 옳은 것은?

| ID | SAL |
| --- | --- |
| 1 | 1000 |
| 2 | 2000 |
| 3 | NULL |

① `SELECT COUNT(SAL) FROM T;` 의 결과는 3이다.

② `SELECT SUM(SAL) FROM T;` 의 결과는 NULL이다.

③ `SELECT AVG(SAL) FROM T;` 는 (1000+2000)/2 의 결과인 1500이다.

④ `SELECT COUNT(*) FROM T;` 는 NULL을 제외하고 2를 반환한다.

* **정답:** ③
* **힌트:** 집계 함수는 NULL을 무시합니다. 단, `COUNT(*)`는 예외입니다.
* **해설:** `COUNT(SAL)`은 2, `SUM(SAL)`은 3000, `AVG(SAL)`은 NULL을 제외한 평균인 1500, `COUNT(*)`는 전체 행 수인 3을 반환합니다.

---

### Q19. NULL 처리 함수에 대한 설명과 예시가 바르게 연결된 것은?

| 함수 | 설명 |
| --- | --- |
| **NVL(A, B)** | A가 NULL이면 B를 반환 |
| **NULLIF(A, B)** | A와 B가 같으면 NULL을 반환 |
| **COALESCE(A, B, C)** | NULL이 아닌 첫 번째 값을 반환 |

① `NVL(NULL, 0)` $\rightarrow$ 결과: NULL

② `NULLIF(10, 10)` $\rightarrow$ 결과: 10

③ `COALESCE(NULL, NULL, 5)` $\rightarrow$ 결과: 5

④ `NVL2(A, B, C)` 는 A가 NULL일 때 B를 반환한다.

* **정답:** ③
* **힌트:** NVL2는 (NULL이 아닐 때, NULL일 때) 순서입니다.
* **해설:** ① 결과는 0, ② 결과는 NULL입니다. ③은 NULL을 건너뛰고 첫 번째 실체인 5를 반환하므로 정답입니다.

---

### Q20. 다음 중 본질식별자와 인조식별자에 대한 설명으로 부적절한 것은?

| 구분 | 설명 |
| --- | --- |
| **본질식별자** | 업무에 의해 자연스럽게 발생하는 식별자 (예: 주민번호, 사번) |
| **인조식별자** | 인위적으로 부여한 식별자 (예: 일련번호) |

① 본질식별자가 복합키로 너무 길어질 경우 인조식별자 도입을 검토한다.

② 인조식별자를 남용하면 중복 데이터 발생 가능성이 높아질 수 있다.

③ 인조식별자는 업무의 의미를 담고 있어 데이터 추적이 용이하다.

④ 인조식별자를 PK로 사용하면 시스템 성능(인덱스 단순화)에 유리할 수 있다.

* **정답:** ③
* **힌트:** '일련번호 1번'이라는 데이터만 보고 이게 무슨 주문인지 알 수 있을까요?
* **해설:** 인조식별자는 가짜 식별자이므로 업무적 의미를 담고 있지 않습니다. 업무 의미는 본질식별자가 가지고 있습니다.
